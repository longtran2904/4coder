
//~ =========================== Namespaces (many forms) ========================

namespace MyCppNamespace
{
    typedef int my_i32;
    typedef unsigned my_u32;
    namespace Hidden { struct Hidden; }
}

namespace outer
{
    int value = 10;
    namespace inner
    {
        int value = 5;
    }
}

// TODO(long): anonymous and using namespaces
//namespace { int internal_counter = 0; }
//{
//using namespace outer;
//value += 20;
//{
//using outer::inner::value;
//value += 10;
//}

//using MyCppNamespace::my_i32;
//my_i32 i32_value;
//}

// TODO(long): namespace asignment
//namespace oi = outer::inner;
///using oi::value;

//~ ======================== Forward decls ====================

struct MyCppStruct;
class MyCppClass;
enum class MyCppEnum : unsigned char;

// TODO(long): type alias
//using i8 = signed char;

//~ ================================ Enums =====================================

enum MyCppFlags {
    F_A = 1,
    F_B = 2,
    F_C = 4,
    F_ALL = F_A | F_B | F_C,
};

enum class MyCppEnum : unsigned char {
    Red   = 0x01,
    Green = 0x02,
    Blue  = 0x04,
};

//~ =============================== Structs/Unions =============================

struct MyCppStruct {
    int a;
    mutable int m;
    unsigned flags;
    
    union
    {
        int   i;
        float f;
    };
    
    struct
    {
        unsigned b1 : 3;
        unsigned    : 2;
        unsigned b2 : 5;
    } bits;
    
    int arr[3];
};

alignas(16) struct SIMD
{
    float data[4];
};

//~ ==================== Typedefs ====================

typedef unsigned long long int my_cpp_ulong, my_cpp_array[10][20], **const**volatile* my_cpp_array_ptr[20][30];

typedef struct {
    int anonymous;
} AnonymousStruct;

typedef struct TypedefStruct
{
    struct { int anonymous; } anonymousDecl;
    struct NamedStruct { int named; } namedDecl;
} TypedefStruct;

typedef class TypedefClass TypedefClass1, TypedefClass2;
typedef TypedefClass2 TypedefClass3;
union TypedefUnion typedefDecl;

//~ ============================ Base / inheritance ============================

class CppBase {
    public:
    virtual ~CppBase() noexcept {}
    virtual int vfunc(int) const = 0;
    
    protected:
    int protected_val;
};

//~ =============================== Classes ====================================

class CppDerive : public CppBase
{
    public:
    typedef int value_type;
    typedef unsigned size_type;
    
    enum State { Idle, Busy, Done };
    
    static int global_int;
    static thread_local int tls;
    
    int field;
    volatile int volatile_field;
    MyCppEnum cpp_enum;
    
    CppDerive() noexcept : field(0), volatile_field(0), cpp_enum(MyCppEnum::Red) { ++global_int; }
    explicit CppDerive(int f) : field(f), volatile_field(0), cpp_enum(MyCppEnum::Red) { ++global_int; }
    CppDerive(int a, int b) : CppDerive(a + b) {}
    CppDerive(const CppDerive&) = default;
    CppDerive(CppDerive&&) noexcept = default;
    ~CppDerive() override { --global_int; }
    
    CppDerive& operator=(const CppDerive&) = delete;
    CppDerive& operator=(CppDerive&&) = default;
    
    int vfunc(int x) const override;
    static int global_func(int) noexcept;
    int member_func(double d) const { return (int)(field + d); }
    
    struct AnotherCppStruct { float value; };
    
    int operator()(int x) const { return field + x; }
    int operator[](int idx) const { return field + idx; }
    explicit operator bool() const { return field != 0; }
    friend CppDerive operator+(const CppDerive& a, const CppDerive& b);
    friend AnotherCppStruct& operator<<(AnotherCppStruct&, const CppDerive&);
    
    private:
    int hidden;
};

int CppDerive::global_int = 0;
thread_local int CppDerive::tls = 0;

struct AnotherCppStruct { int value; };

inline CppDerive operator+(const CppDerive& a, const CppDerive& b) {
    return CppDerive(a.field + b.field);
}

inline AnotherCppStruct& operator<<(AnotherCppStruct& os, const CppDerive& w)
{
    (void)w;
    return os;
}

int CppDerive::vfunc(int x) const { return field + x; }
int CppDerive::global_func(int x) noexcept { return x + 1; }

//~ ============================ Extern "C" block ==============================

extern "C" {
    void c_function(int);
    extern int c_global_1;
    extern int c_global_2;
}

//~ ============================= Declarations =================================

float cpp_decl1, **cpp_decl2, &*const**volatile*** cpp_decl3[10][20];

extern int cpp_extern_int;
static int cpp_intern_int = 1;

// TODO(long): pointer-to-member declarator
//int CppDerive::* g_pm_data  = &CppDerive::field;
//int (CppDerive::* g_pm_func)(double) const = &CppDerive::member_func;
//int pm_int = w.*g_pm_data;
//pm_int += (w.*g_pm_func)(1.5);

// TODO(long): trailing return type
//auto trailing()->int;
//auto trailing()->int { return 42; }

int CppFunc1(int (*fp)(int), int x = 0);
int CppFunc2(const char* fmt, ...);
int CppFunc3();
int CppFunc4() noexcept(noexcept(CppFunc3()));

int*** global_array[10][20];
constexpr int const_int = 100;
static int const * const ** volatile *** const cpp_complex_decl[20][20];

const char* raw      = R"(line1\nline2)";
const char16_t* w16  = u"wide16";
const char32_t* w32  = U"wide32";
char ch = 'a';
char16_t c16 = u'a';
char32_t c32 = U'a';

static_assert(alignof(SIMD) == 16, "SIMD must be 16-byte aligned");
auto auto_int = 123u;

// TODO(long): decltype
//decltype(CppDerive::field) svar_like = 5;

// TODO(long): user-defined literal operator
//unsigned long long operator "" _ticks(unsigned long long v) { return v; }

//~ ================================ Namespace stuff ===========================

namespace CppMath
{
    double add(double a, double b);
    inline double add_inline(double a, double b) { return a + b; }
    
    struct Point
    {
        double x;
        double y;
        Point();
        Point(double, double);
    };
}

double CppMath::add(double a, double b) { return a + b; }
CppMath::Point::Point() : x(0.0), y(0.0) {}
CppMath::Point::Point(double xx, double yy) : x(xx), y(yy) {}

int CppFunc1(int (*fp)(int), int x) { return fp ? fp(x) : x; }
int CppFunc2(const char*, ...) { return 0; }
int CppFunc3() { return 1; }
int CppFunc4() noexcept(noexcept(CppFunc3())) { return CppFunc3(); }

int sum(int a, int b = 5) {
    return a + b;
}

int cpp_extern_int = 99;

int demo_decls(int p1, int p2 = 2 * 3)
{
    auto local_auto = p1 + p2;
    int arr[3] = {1, 2, 3};
    volatile int v = 0;
    
    // Local class
    struct LocalClass
    {
        int y;
        int f() { return y; }
    } loc{5};
    
    enum LocalEnum { One, Two, Three };
    LocalEnum e = Two;
    
    CppDerive w(local_auto);
    return w(arr[0]) + w[1] + CppDerive::global_func(3);
}

extern "C" void c_function(int)
{
    c_global_2 = 100;
    internal_counter += 1;
}
extern "C" int c_global_1 = 0;

//~ ================================ main() ====================================

int main() {
    MyCppNamespace::i32 x = 10;
    
    MyCppEnum c = MyCppEnum::Green;
    (void)c;
    
    CppDerive a(2), b(3);
    CppDerive csum = a + b;
    AnotherCppStruct s;
    s << csum;
    
    //int forty_two = trailing();
    //auto t = 100_ticks;
    //(void)t;
    
    int applied = CppFunc1(0, 5);
    (void)applied;
    
    return forty_two;
}

#include "4coder_base_types.h"
#include "4coder_token.h"
#include "generated/lexer_cpp.h"

#include "4coder_base_types.cpp"
#include "4coder_token.cpp"
#include "generated/lexer_cpp.cpp"

#include "4coder_stringf.cpp"
#include "4coder_malloc_allocator.cpp"

#include <stdio.h>
#include <time.h>

internal void CPP_Print(Token_List *list, String_Const_u8 text)
{
    for (Token_Block *block = list->first;
         block != 0;
         block = block->next){
        i32 count = block->count;
        Token *token = block->tokens;
        for (i32 i = 0; i < count; i += 1, token += 1){
            printf("[%5llu, %5llu) %20s / %20s : 0x%04x / 0x%04x\n",
                   token->pos, token->pos + token->size,
                   token_base_kind_names[token->kind],
                   token_cpp_kind_names[token->sub_kind],
                   token->flags, token->sub_flags);
            printf("\t:%.*s:\n", (i32)token->size, text.str + token->pos);
        }
    }
}

internal String_Const_u8 CPP_Read(Arena *arena, FILE *file)
{
    String_Const_u8 result = {};
    fseek(file, 0, SEEK_END);
    result.size = ftell(file);
    fseek(file, 0, SEEK_SET);
    result.str = push_array(arena, u8, result.size + 1);
    fread(result.str, result.size, 1, file);
    result.str[result.size] = 0;
    return(result);
}

int CPP_Process(void)
{
    Arena arena_ = make_arena_malloc();
    Arena *arena = &arena_;
    
    String_Const_u8 path_to_self = string_u8_litexpr(__FILE__);
    path_to_self = string_remove_last_folder(path_to_self);
    String_Const_u8 path_to_src = string_remove_last_folder(path_to_self);
    
    String_Const_u8 test_file_name = push_u8_stringf(arena, "%.*s/languages/4coder_lexer_cpp_test.cpp",
                                                     string_expand(path_to_src));
    
    FILE *test_file = fopen((char*)test_file_name.str, "rb");
    if (test_file == 0){
        printf("error: count not open test file %s\n", test_file_name.str);
        exit(1);
    }
    String_Const_u8 text = file_read_all(arena, test_file);
    fclose(test_file);
    
    Token_List list = lex_full_input_cpp(arena, text);
    print_token_list(&list, text);
    
    for (i32 i = 0; i < KB(4); i += 1){
        fprintf(stdout, "\n");
    }
    fflush(stdout);
}
