#if !defined(FCODER_LEX_GEN_HAND_WRITTEN_TYPES)
#define FCODER_LEX_GEN_HAND_WRITTEN_TYPES

struct Lexeme_Table_Value{
    Token_Base_Kind base_kind;
    u16 sub_kind;
};

struct Lexeme_Table_Lookup{
    b32 found_match;
    Token_Base_Kind base_kind;
    u16 sub_kind;
};

#endif
typedef u16 Token_Cs_Kind;
enum{
TokenCsKind_EOF = 0,
TokenCsKind_Whitespace = 1,
TokenCsKind_LexError = 2,
TokenCsKind_BlockComment = 3,
TokenCsKind_LineComment = 4,
TokenCsKind_Backslash = 5,
TokenCsKind_LiteralInteger = 6,
TokenCsKind_LiteralIntegerU = 7,
TokenCsKind_LiteralIntegerL = 8,
TokenCsKind_LiteralIntegerUL = 9,
TokenCsKind_LiteralIntegerLL = 10,
TokenCsKind_LiteralIntegerULL = 11,
TokenCsKind_LiteralIntegerHex = 12,
TokenCsKind_LiteralIntegerHexU = 13,
TokenCsKind_LiteralIntegerHexL = 14,
TokenCsKind_LiteralIntegerHexUL = 15,
TokenCsKind_LiteralIntegerHexLL = 16,
TokenCsKind_LiteralIntegerHexULL = 17,
TokenCsKind_LiteralIntegerOct = 18,
TokenCsKind_LiteralIntegerOctU = 19,
TokenCsKind_LiteralIntegerOctL = 20,
TokenCsKind_LiteralIntegerOctUL = 21,
TokenCsKind_LiteralIntegerOctLL = 22,
TokenCsKind_LiteralIntegerOctULL = 23,
TokenCsKind_LiteralFloat32 = 24,
TokenCsKind_LiteralFloat64 = 25,
TokenCsKind_LiteralString = 26,
TokenCsKind_LiteralStringWide = 27,
TokenCsKind_LiteralStringUTF8 = 28,
TokenCsKind_LiteralStringUTF16 = 29,
TokenCsKind_LiteralStringUTF32 = 30,
TokenCsKind_LiteralStringRaw = 31,
TokenCsKind_LiteralStringWideRaw = 32,
TokenCsKind_LiteralStringUTF8Raw = 33,
TokenCsKind_LiteralStringUTF16Raw = 34,
TokenCsKind_LiteralStringUTF32Raw = 35,
TokenCsKind_LiteralCharacter = 36,
TokenCsKind_LiteralCharacterWide = 37,
TokenCsKind_LiteralCharacterUTF8 = 38,
TokenCsKind_LiteralCharacterUTF16 = 39,
TokenCsKind_LiteralCharacterUTF32 = 40,
TokenCsKind_PPErrorMessage = 41,
TokenCsKind_KeywordGeneric = 42,
TokenCsKind_BraceOp = 43,
TokenCsKind_BraceCl = 44,
TokenCsKind_ParenOp = 45,
TokenCsKind_BrackOp = 46,
TokenCsKind_ParenCl = 47,
TokenCsKind_BrackCl = 48,
TokenCsKind_Semicolon = 49,
TokenCsKind_Colon = 50,
TokenCsKind_DotDotDot = 51,
TokenCsKind_PlusPlus = 52,
TokenCsKind_MinusMinus = 53,
TokenCsKind_Dot = 54,
TokenCsKind_Arrow = 55,
TokenCsKind_Plus = 56,
TokenCsKind_Minus = 57,
TokenCsKind_Not = 58,
TokenCsKind_Tilde = 59,
TokenCsKind_Star = 60,
TokenCsKind_And = 61,
TokenCsKind_DotStar = 62,
TokenCsKind_ArrowStar = 63,
TokenCsKind_Div = 64,
TokenCsKind_Mod = 65,
TokenCsKind_TernaryDot = 66,
TokenCsKind_TernaryTernary = 67,
TokenCsKind_TernaryDotStar = 68,
TokenCsKind_LeftLeft = 69,
TokenCsKind_RightRight = 70,
TokenCsKind_Compare = 71,
TokenCsKind_Less = 72,
TokenCsKind_LessEq = 73,
TokenCsKind_Grtr = 74,
TokenCsKind_GrtrEq = 75,
TokenCsKind_EqEq = 76,
TokenCsKind_NotEq = 77,
TokenCsKind_Xor = 78,
TokenCsKind_Or = 79,
TokenCsKind_AndAnd = 80,
TokenCsKind_OrOr = 81,
TokenCsKind_Ternary = 82,
TokenCsKind_Eq = 83,
TokenCsKind_PlusEq = 84,
TokenCsKind_MinusEq = 85,
TokenCsKind_StarEq = 86,
TokenCsKind_DivEq = 87,
TokenCsKind_ModEq = 88,
TokenCsKind_TernaryEq = 89,
TokenCsKind_EqGrtr = 90,
TokenCsKind_LeftLeftEq = 91,
TokenCsKind_RightRightEq = 92,
TokenCsKind_Comma = 93,
TokenCsKind_Abstract = 94,
TokenCsKind_As = 95,
TokenCsKind_Base = 96,
TokenCsKind_Bool = 97,
TokenCsKind_Break = 98,
TokenCsKind_Byte = 99,
TokenCsKind_Case = 100,
TokenCsKind_Catch = 101,
TokenCsKind_Char = 102,
TokenCsKind_Checked = 103,
TokenCsKind_Class = 104,
TokenCsKind_Const = 105,
TokenCsKind_Continue = 106,
TokenCsKind_Decimal = 107,
TokenCsKind_Default = 108,
TokenCsKind_Delegate = 109,
TokenCsKind_Do = 110,
TokenCsKind_Double = 111,
TokenCsKind_Else = 112,
TokenCsKind_Enum = 113,
TokenCsKind_Event = 114,
TokenCsKind_Explicit = 115,
TokenCsKind_Extern = 116,
TokenCsKind_False = 117,
TokenCsKind_Finally = 118,
TokenCsKind_Fixed = 119,
TokenCsKind_Float = 120,
TokenCsKind_For = 121,
TokenCsKind_Foreach = 122,
TokenCsKind_Goto = 123,
TokenCsKind_If = 124,
TokenCsKind_Implicit = 125,
TokenCsKind_In = 126,
TokenCsKind_Int = 127,
TokenCsKind_Interface = 128,
TokenCsKind_Internal = 129,
TokenCsKind_Is = 130,
TokenCsKind_Lock = 131,
TokenCsKind_Long = 132,
TokenCsKind_Namespace = 133,
TokenCsKind_New = 134,
TokenCsKind_Null = 135,
TokenCsKind_Object = 136,
TokenCsKind_Operator = 137,
TokenCsKind_Out = 138,
TokenCsKind_Override = 139,
TokenCsKind_Params = 140,
TokenCsKind_Private = 141,
TokenCsKind_Protected = 142,
TokenCsKind_Public = 143,
TokenCsKind_Readonly = 144,
TokenCsKind_Ref = 145,
TokenCsKind_Return = 146,
TokenCsKind_Sbyte = 147,
TokenCsKind_Sealed = 148,
TokenCsKind_Short = 149,
TokenCsKind_Sizeof = 150,
TokenCsKind_Stackalloc = 151,
TokenCsKind_Static = 152,
TokenCsKind_String = 153,
TokenCsKind_Struct = 154,
TokenCsKind_Switch = 155,
TokenCsKind_This = 156,
TokenCsKind_Throw = 157,
TokenCsKind_True = 158,
TokenCsKind_Try = 159,
TokenCsKind_Typeof = 160,
TokenCsKind_Uint = 161,
TokenCsKind_Ulong = 162,
TokenCsKind_Unchecked = 163,
TokenCsKind_Unsafe = 164,
TokenCsKind_Ushort = 165,
TokenCsKind_Using = 166,
TokenCsKind_Virtual = 167,
TokenCsKind_Void = 168,
TokenCsKind_Volatile = 169,
TokenCsKind_While = 170,
TokenCsKind_Var = 171,
TokenCsKind_Yield = 172,
TokenCsKind_Where = 173,
TokenCsKind_Identifier = 174,
TokenCsKind_PPDefine = 175,
TokenCsKind_PPUndef = 176,
TokenCsKind_PPRegion = 177,
TokenCsKind_PPEndRegion = 178,
TokenCsKind_PPIf = 179,
TokenCsKind_PPElse = 180,
TokenCsKind_PPElIf = 181,
TokenCsKind_PPEndIf = 182,
TokenCsKind_PPError = 183,
TokenCsKind_PPWarning = 184,
TokenCsKind_PPLine = 185,
TokenCsKind_PPPragma = 186,
TokenCsKind_PPUnknown = 187,
TokenCsKind_COUNT = 188,
};
char *token_cs_kind_names[] = {
"EOF",
"Whitespace",
"LexError",
"BlockComment",
"LineComment",
"Backslash",
"LiteralInteger",
"LiteralIntegerU",
"LiteralIntegerL",
"LiteralIntegerUL",
"LiteralIntegerLL",
"LiteralIntegerULL",
"LiteralIntegerHex",
"LiteralIntegerHexU",
"LiteralIntegerHexL",
"LiteralIntegerHexUL",
"LiteralIntegerHexLL",
"LiteralIntegerHexULL",
"LiteralIntegerOct",
"LiteralIntegerOctU",
"LiteralIntegerOctL",
"LiteralIntegerOctUL",
"LiteralIntegerOctLL",
"LiteralIntegerOctULL",
"LiteralFloat32",
"LiteralFloat64",
"LiteralString",
"LiteralStringWide",
"LiteralStringUTF8",
"LiteralStringUTF16",
"LiteralStringUTF32",
"LiteralStringRaw",
"LiteralStringWideRaw",
"LiteralStringUTF8Raw",
"LiteralStringUTF16Raw",
"LiteralStringUTF32Raw",
"LiteralCharacter",
"LiteralCharacterWide",
"LiteralCharacterUTF8",
"LiteralCharacterUTF16",
"LiteralCharacterUTF32",
"PPErrorMessage",
"KeywordGeneric",
"BraceOp",
"BraceCl",
"ParenOp",
"BrackOp",
"ParenCl",
"BrackCl",
"Semicolon",
"Colon",
"DotDotDot",
"PlusPlus",
"MinusMinus",
"Dot",
"Arrow",
"Plus",
"Minus",
"Not",
"Tilde",
"Star",
"And",
"DotStar",
"ArrowStar",
"Div",
"Mod",
"TernaryDot",
"TernaryTernary",
"TernaryDotStar",
"LeftLeft",
"RightRight",
"Compare",
"Less",
"LessEq",
"Grtr",
"GrtrEq",
"EqEq",
"NotEq",
"Xor",
"Or",
"AndAnd",
"OrOr",
"Ternary",
"Eq",
"PlusEq",
"MinusEq",
"StarEq",
"DivEq",
"ModEq",
"TernaryEq",
"EqGrtr",
"LeftLeftEq",
"RightRightEq",
"Comma",
"Abstract",
"As",
"Base",
"Bool",
"Break",
"Byte",
"Case",
"Catch",
"Char",
"Checked",
"Class",
"Const",
"Continue",
"Decimal",
"Default",
"Delegate",
"Do",
"Double",
"Else",
"Enum",
"Event",
"Explicit",
"Extern",
"False",
"Finally",
"Fixed",
"Float",
"For",
"Foreach",
"Goto",
"If",
"Implicit",
"In",
"Int",
"Interface",
"Internal",
"Is",
"Lock",
"Long",
"Namespace",
"New",
"Null",
"Object",
"Operator",
"Out",
"Override",
"Params",
"Private",
"Protected",
"Public",
"Readonly",
"Ref",
"Return",
"Sbyte",
"Sealed",
"Short",
"Sizeof",
"Stackalloc",
"Static",
"String",
"Struct",
"Switch",
"This",
"Throw",
"True",
"Try",
"Typeof",
"Uint",
"Ulong",
"Unchecked",
"Unsafe",
"Ushort",
"Using",
"Virtual",
"Void",
"Volatile",
"While",
"Var",
"Yield",
"Where",
"Identifier",
"PPDefine",
"PPUndef",
"PPRegion",
"PPEndRegion",
"PPIf",
"PPElse",
"PPElIf",
"PPEndIf",
"PPError",
"PPWarning",
"PPLine",
"PPPragma",
"PPUnknown",
};
