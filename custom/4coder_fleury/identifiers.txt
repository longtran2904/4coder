NULL: UnityEngine
[NULL] test_global_1 { declaration [global] }
[NULL] test_global_2 { declaration [global] }
[{] test_local_1 { <{> declaration [local] }
[{] test_local_2 { <{> declaration [local] }
[NULL] MyGenericType { type [def] [product] }
[MyGenericType] T { <MyGenericType> type [def] [product] }
[MyGenericType] a { <MyGenericType> declaration [field] }
[MyGenericType] T { <MyGenericType> type [def] [product] }
[MyGenericType] b { <MyGenericType> declaration [field] }
[MyGenericType] DoShit { <MyGenericType> function [def] }
[DoShit] someArg { <DoShit> declaration [argument] }
[MyGenericType] T { <MyGenericType> type [def] [product] }
[MyGenericType] DoGenericShit { <MyGenericType> function [def] }
[DoGenericShit] U { <DoGenericShit> type [def] [product] }
[MyGenericType] T { <MyGenericType> type [def] [product] }
[DoGenericShit] a { <DoGenericShit> declaration [argument] }
[DoGenericShit] U { <DoGenericShit> type [def] [product] }
[DoGenericShit] b { <DoGenericShit> declaration [argument] }
[DoGenericShit] a { <DoGenericShit> declaration [argument] }
[NULL] GenericFunc { function [def] }
[GenericFunc] T { <GenericFunc> type [def] [product] }
[GenericFunc] arg { <GenericFunc> declaration [argument] }
[GenericFunc] T { <GenericFunc> type [def] [product] }
[GenericFunc] a { <GenericFunc> declaration [local] }
[NULL] TesStruct { type [def] [product] }
[NULL] TestSingleEnum { type [def] [product] }
[NULL] EnumTest { type [def] [product] }
[EnumTest] A { <EnumTest> constant }
[EnumTest] B { <EnumTest> constant }
[EnumTest] C { <EnumTest> constant }
NULL: fjldasd
[NULL] TestNamespace { type [def] [product] }
[TestNamespace] Namespace { <TestNamespace> declaration [field] }
[NULL] TestNamespace { type [def] [product] }
[TestNamespace] A { <TestNamespace> type [def] [product] }
[A] B { <A> type [def] [product] }
[B] C { <B> type [def] [product] }
[C] Namespace { <C> function [def] }
[NULL] TestNamespace { type [def] [product] }
[TestNamespace] A { <TestNamespace> type [def] [product] }
[NULL] TestNamespace { type [def] [product] }
[TestNamespace] A { <TestNamespace> type [def] [product] }
[A] B { <A> type [def] [product] }
[B] Namespace { <B> type [def] [product] }
[NULL] verbatimStr3 { declaration [global] }
[NULL] interpolStr { declaration [global] }
NULL: Something
[NULL] normalStr { declaration [global] }
[NULL] TestNamespace { type [def] [product] }
[TestNamespace] Namespace { <TestNamespace> declaration [field] }
[NULL] TestNamespace { type [def] [product] }
[TestNamespace] A { <TestNamespace> type [def] [product] }
[A] B { <A> type [def] [product] }
[B] C { <B> type [def] [product] }
[C] Namespace { <C> function [def] }
[NULL] TEST_MACRO { macro }
[NULL] TEST_MACRO { macro }
[NULL] handsome { declaration [global] }
[NULL] Test { type [def] [product] }
[NULL] testDecl1 { declaration [global] }
[NULL] Test { type [def] [product] }
[Test] Stuff { <Test> type [def] [product] }
[NULL] testDecl2 { declaration [global] }
[NULL] Test { type [def] [product] }
[NULL] CreateTest { function [def] }
[CreateTest] a { <CreateTest> declaration [argument] }
[CreateTest] b { <CreateTest> declaration [argument] }
[CreateTest] c { <CreateTest> declaration [argument] }
[NULL] Test { type [def] [product] }
[Test] Stuff { <Test> type [def] [product] }
[NULL] VeryLongFunction { function [def] }
[NULL] Test { type [def] [product] }
[Test] Stuff { <Test> type [def] [product] }
[VeryLongFunction] something { <VeryLongFunction> declaration [argument] }
[VeryLongFunction] someOtherThing { <VeryLongFunction> declaration [argument] }
[VeryLongFunction] fl { <VeryLongFunction> declaration [argument] }
[NULL] Optional { type [def] [product] }
[VeryLongFunction] optionals { <VeryLongFunction> declaration [argument] }
[NULL] OtherTest { type [def] [product] }
[VeryLongFunction] others { <VeryLongFunction> declaration [argument] }
[VeryLongFunction] veryLongArg { <VeryLongFunction> declaration [argument] }
[NULL] Entity { type [def] [product] }
NULL: A
NULL: EntityAbility
[VeryLongFunction] anotherLongArg { <VeryLongFunction> declaration [argument] }
[VeryLongFunction] values { <VeryLongFunction> declaration [argument] }
NULL: Generic
NULL: Type
NULL: T
[VeryLongFunction] a { <VeryLongFunction> declaration [argument] }
NULL: SomeOtherType
[VeryLongFunction] type { <VeryLongFunction> declaration [argument] }
NULL: System
NULL: Type
[VeryLongFunction] otherType { <VeryLongFunction> declaration [argument] }
[NULL] EnumTest { type [def] [product] }
[VeryLongFunction] enumTest { <VeryLongFunction> declaration [argument] }
NULL: TestStruct
[VeryLongFunction] testStruct { <VeryLongFunction> declaration [argument] }
[NULL] TestSingleEnum { type [def] [product] }
[VeryLongFunction] senum { <VeryLongFunction> declaration [argument] }
NULL: AnotherArg
[VeryLongFunction] arg { <VeryLongFunction> declaration [argument] }
NULL: UNKNOW
[NULL] handsome { declaration [global] }
[NULL] Vector2 { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
[+] a { <+> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[+] b { <+> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
[-] a { <-> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
[-] a { <-> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[-] b { <-> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[*] d { <*> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[*] a { <*> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
[*] a { <*> declaration [argument] }
[*] d { <*> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
[*] a { <*> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[*] b { <*> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
[/] a { </> declaration [argument] }
[/] d { </> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
[/] a { </> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[/] b { </> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[==] lhs { <==> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[==] rhs { <==> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[!=] lhs { <!=> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[!=] rhs { <!=> declaration [argument] }
[Vector2] Vector2 { <Vector2> operator [def] }
[Vector2] Vector3 { <Vector2> operator [def] }
[Vector2] v { <Vector2> declaration [argument] }
[Vector2] Vector3 { <Vector2> operator [def] }
[NULL] Vector2 { type [def] [product] }
[Vector3] v { <Vector3> declaration [argument] }
NULL: NewLine
NULL: a
NULL: b
NULL: SomeOtherThing
NULL: Multiple
NULL: System
NULL: Serializable
NULL: System
NULL: OtherCrap
[NULL] Test { type [def] [product] }
[Test] DoStuff { <Test> declaration [field] }
NULL: A
[NULL] B { macro }
NULL: C
[Test] d { <Test> declaration [field] }
NULL: Some
NULL: Other
NULL: Thing
NULL: I
NULL: Hate
[Test] a { <Test> declaration [field] }
[Test] a { <Test> declaration [field] }
[Test] b { <Test> declaration [field] }
[Test] c { <Test> declaration [field] }
[Test] d { <Test> declaration [field] }
[Test] f { <Test> declaration [field] }
[Test] h { <Test> declaration [field] }
[Test] efldsfjsl { <Test> declaration [field] }
[Test] a { <Test> declaration [field] }
[Test] c { <Test> declaration [field] }
[Test] tupple { <Test> declaration [field] }
[Test] Function { <Test> function [def] }
[Function] someInt { <Function> declaration [argument] }
[Function] someFloat { <Function> declaration [argument] }
NULL: Generic
[NULL] Test { type [def] [product] }
NULL: SomeOtherType
NULL: Array
[Test] Function2 { <Test> function [def] }
[Test] Test { <Test> constructor [def] }
[Test] property { <Test> declaration [property] }
[property] get { <property> getter [def] }
NULL: SomeFunc
[] _ { <> declaration [argument] }
[] a { <> declaration [local] }
[property] set { <property> setter [def] }
[set] b { <set> declaration [local] }
NULL: SomeOtherFunc
[] x { <> declaration [argument] }
[] y { <> declaration [argument] }
[] z { <> declaration [argument] }
[Test] Something { <Test> function [def] }
[Something] a { <Something> declaration [local] }
NULL: A
NULL: System
NULL: Action
[Something] b { <Something> declaration [local] }
[] e { <> declaration [argument] }
[] f { <> declaration [argument] }
[] g { <> declaration [argument] }
[Something] a { <Something> declaration [local] }
[Something] b { <Something> declaration [local] }
[{] b { <{> declaration [local] }
[] e { <> declaration [argument] }
[] f { <> declaration [argument] }
[] g { <> declaration [argument] }
[Test] DoStuff { <Test> declaration [field] }
[{] b { <{> declaration [local] }
[Something] c { <Something> declaration [local] }
[{] Stuff { <{> function [def] }
[{] Stuff { <{> function [def] }
[NULL] Test { type [def] [product] }
[Test] Stuff { <Test> type [def] [product] }
[{] a { <{> declaration [local] }
[{] DoStuff { <{> declaration [local] }
[{] DoStuff { <{> declaration [local] }
[{] DoStuff { <{> declaration [local] }
[{] DoStuff { <{> declaration [local] }
[{] DoStuff { <{> function [def] }
[DoStuff] a { <DoStuff> declaration [local] }
[DoStuff] b { <DoStuff> declaration [local] }
[{] DoStuff { <{> function [def] }
[NULL] Test { type [def] [product] }
[Test] Something { <Test> function [def] }
[NULL] VeryLongFunction { function [def] }
[Test] Function { <Test> function [def] }
[Something] a { <Something> declaration [local] }
[Test] d { <Test> declaration [field] }
[Test] SomeOtherThing { <Test> function [def] }
[NULL] Test { type [def] [product] }
[Test] DoStuff { <Test> declaration [field] }
[NULL] VeryLongFunction { function [def] }
[NULL] Test { type [def] [product] }
[Test] Stuff { <Test> type [def] [product] }
[{] stuff { <{> declaration [local] }
[{] stuff { <{> declaration [local] }
[Stuff] DoStuff { <Stuff> function [def] }
[{] A { <{> function [def] }
[A] a { <A> declaration [argument] }
[A] b { <A> declaration [argument] }
[{] B { <{> function [def] }
[B] a { <B> declaration [argument] }
[B] b { <B> declaration [argument] }
[B] c { <B> declaration [argument] }
[{] A { <{> function [def] }
[{] B { <{> function [def] }
[Test] Something { <Test> function [def] }
[NULL] Optional { type [def] [product] }
[Optional] Optional { <Optional> constructor [def] }
[NULL] Test { type [def] [product] }
[Test] Stuff { <Test> type [def] [product] }
[Stuff] DoStuff { <Stuff> function [def] }
[Something] a { <Something> declaration [local] }
[NULL] Test { type [def] [product] }
[{] t { <{> declaration [local] }
[NULL] Test { type [def] [product] }
[{] t { <{> declaration [local] }
[Test] DoStuff { <Test> declaration [field] }
[{] t { <{> declaration [local] }
[Test] Something { <Test> function [def] }
[NULL] CreateTest { function [def] }
[Test] Something { <Test> function [def] }
NULL: something
[NULL] Vector2 { type [def] [product] }
NULL: TestIf
NULL: ifDecl
[Test] DoStuff { <Test> declaration [field] }
[NULL] Test { type [def] [product] }
[Test] DoStuff { <Test> declaration [field] }
[Test] Stuff { <Test> type [def] [product] }
[Stuff] DoStuff { <Stuff> function [def] }
[NULL] OtherTest { type [def] [product] }
[OtherTest] DoStuff { <OtherTest> function [def] }
[Test] SomeOtherThing { <Test> function [def] }
[SomeOtherThing] DoStuff { <SomeOtherThing> declaration [argument] }
[NULL] Test { type [def] [product] }
[Test] DoStuff { <Test> declaration [field] }
[SomeOtherThing] a { <SomeOtherThing> declaration [local] }
[SomeOtherThing] DoStuff { <SomeOtherThing> declaration [argument] }
[Test] Stuff { <Test> type [def] [product] }
[Stuff] DoStuff { <Stuff> function [def] }
[DoStuff] DoStuff { <DoStuff> function [def] }
[DoStuff] DoStuff { <DoStuff> function [def] }
[Stuff] DoStuff { <Stuff> function [def] }
[Test] Stuff { <Test> type [def] [product] }
[Stuff] DoStuff { <Stuff> function [def] }
[DoStuff] DoStuff { <DoStuff> function [def] }
[DoStuff] DoStuff { <DoStuff> function [def] }
[Stuff] DoStuff { <Stuff> function [def] }
[NULL] OtherTest { type [def] [product] }
[OtherTest] DoStuff { <OtherTest> function [def] }
[NULL] Stuff { type [def] [product] }
[Stuff] DoStuff { <Stuff> declaration [field] }
NULL: System
NULL: Serializable
[NULL] Optional { type [def] [product] }
[Optional] T { <Optional> type [def] [product] }
[Optional] enabled { <Optional> declaration [field] }
[Optional] T { <Optional> type [def] [product] }
[Optional] value { <Optional> declaration [field] }
[Optional] some { <Optional> declaration [field] }
NULL: Something
[Optional] something { <Optional> declaration [field] }
[Optional] ConstantNumber { <Optional> declaration [field] }
[Optional] SmoothFunc { <Optional> type [def] [product] }
[SmoothFunc] a { <SmoothFunc> declaration [argument] }
[SmoothFunc] b { <SmoothFunc> declaration [argument] }
[Optional] SomeOtherDelegate { <Optional> type [def] [product] }
[SomeOtherDelegate] arr { <SomeOtherDelegate> declaration [argument] }
NULL: b
NULL: Generic
[Optional] T { <Optional> type [def] [product] }
[SomeOtherDelegate] c { <SomeOtherDelegate> declaration [argument] }
[SomeOtherDelegate] d { <SomeOtherDelegate> declaration [argument] }
[Optional] Optional { <Optional> constructor [def] }
[Optional] T { <Optional> type [def] [product] }
[Optional] initValue { <Optional> declaration [argument] }
[Optional] enabled { <Optional> declaration [field] }
[Optional] value { <Optional> declaration [field] }
[Optional] initValue { <Optional> declaration [argument] }
[Optional] Optional { <Optional> constructor [def] }
[Optional] enabled { <Optional> declaration [field] }
[Optional] T { <Optional> operator [def] }
[NULL] Optional { type [def] [product] }
[Optional] T { <Optional> type [def] [product] }
[T] optional { <T> declaration [argument] }
NULL: a
NULL: b
NULL: b
[T] c { <T> declaration [local] }
[T] optional { <T> declaration [argument] }
NULL: value
NULL: otherThing
[Optional] SomeFunc1 { <Optional> function [def] }
[SomeFunc1] a { <SomeFunc1> declaration [argument] }
[SomeFunc1] a { <SomeFunc1> declaration [local] }
[SomeFunc1] b { <SomeFunc1> declaration [local] }
[Optional] SomeFunc2 { <Optional> function [def] }
[SomeFunc2] a { <SomeFunc2> declaration [argument] }
[SomeFunc2] b { <SomeFunc2> declaration [local] }
NULL: A
[Optional] T { <Optional> type [def] [product] }
[Optional] GenericFunc { <Optional> function [def] }
[GenericFunc] a { <GenericFunc> declaration [argument] }
[NULL] Optional { type [def] [product] }
[Optional] DoStuff { <Optional> function [def] }
[NULL] Optional { type [def] [product] }
[DoStuff] args { <DoStuff> declaration [argument] }
[Optional] DoStuff { <Optional> function [def] }
[DoStuff] args { <DoStuff> declaration [argument] }
[NULL] Optional { type [def] [product] }
[Optional] DoStuff { <Optional> function [def] }
[NULL] Test { type [def] [product] }
[Test] DoStuff { <Test> declaration [field] }
[NULL] Property { type [def] [product] }
[Property] T { <Property> type [def] [product] }
NULL: ISerializationCallbackReceiver
[Property] T { <Property> type [def] [product] }
NULL: System
NULL: Enum
[Property] serializedEnumNames { <Property> declaration [field] }
[Property] properties { <Property> declaration [field] }
[Property] enumNames { <Property> declaration [property] }
NULL: System
NULL: Enum
NULL: GetNames
[Property] T { <Property> type [def] [product] }
NULL: Header
[Property] Property { <Property> constructor [def] }
[Property] T { <Property> type [def] [product] }
[Property] properties { <Property> declaration [argument] }
NULL: DoStuff
[Property] properties { <Property> declaration [argument] }
[NULL] Optional { type [def] [product] }
[Optional] DoStuff { <Optional> function [def] }
[Property] names { <Property> declaration [local] }
[Property] enumNames { <Property> declaration [property] }
NULL: GameDebug
NULL: Assert
[Property] names { <Property> declaration [local] }
NULL: Length
[Property] names { <Property> declaration [local] }
NULL: Length
NULL: GameDebug
NULL: Assert
[Property] properties { <Property> declaration [argument] }
NULL: Length
[Property] names { <Property> declaration [local] }
NULL: Length
[Property] properties { <Property> declaration [argument] }
NULL: Length
[Property] SetProperties { <Property> function [def] }
[Property] properties { <Property> declaration [argument] }
[Property] Stuff { <Property> function [def] }
[Property] HasProperty { <Property> function [def] }
[Property] T { <Property> type [def] [product] }
[HasProperty] property { <HasProperty> declaration [argument] }
[HasProperty] p { <HasProperty> declaration [local] }
NULL: System
NULL: Convert
NULL: ToInt32
[HasProperty] property { <HasProperty> declaration [argument] }
[Property] properties { <Property> declaration [field] }
[HasProperty] p { <HasProperty> declaration [local] }
[Property] SetProperty { <Property> function [def] }
[Property] T { <Property> type [def] [product] }
[SetProperty] property { <SetProperty> declaration [argument] }
[SetProperty] set { <SetProperty> declaration [argument] }
[SetProperty] p { <SetProperty> declaration [local] }
NULL: System
NULL: Convert
NULL: ToInt32
[SetProperty] property { <SetProperty> declaration [argument] }
[Property] properties { <Property> declaration [field] }
NULL: MathUtils
NULL: SetFlag
[Property] properties { <Property> declaration [field] }
[SetProperty] p { <SetProperty> declaration [local] }
[SetProperty] set { <SetProperty> declaration [argument] }
[Property] SetProperties { <Property> function [def] }
[Property] T { <Property> type [def] [product] }
[SetProperties] properties { <SetProperties> declaration [argument] }
[SetProperties] properties { <SetProperties> declaration [argument] }
[Property] T { <Property> type [def] [product] }
[SetProperties] property { <SetProperties> declaration [local] }
[SetProperties] properties { <SetProperties> declaration [argument] }
[Property] SetProperty { <Property> function [def] }
[SetProperties] property { <SetProperties> declaration [local] }
[Property] ToString { <Property> function [def] }
[Property] T { <Property> type [def] [product] }
[Property] properties { <Property> declaration [field] }
[Property] OnBeforeSerialize { <Property> function [def] }
[Property] OnAfterDeserialize { <Property> function [def] }
[OnAfterDeserialize] enumNames { <OnAfterDeserialize> declaration [local] }
[Property] enumNames { <Property> declaration [property] }
NULL: Debug
NULL: Assert
[OnAfterDeserialize] enumNames { <OnAfterDeserialize> declaration [local] }
NULL: Length
[Property] T { <Property> type [def] [product] }
NULL: FullName
[OnAfterDeserialize] enumNames { <OnAfterDeserialize> declaration [local] }
NULL: Length
NULL: Debug
NULL: Assert
[OnAfterDeserialize] enumNames { <OnAfterDeserialize> declaration [local] }
NULL: Length
[Property] T { <Property> type [def] [product] }
NULL: FullName
[Property] serializedEnumNames { <Property> declaration [field] }
[Property] serializedEnumNames { <Property> declaration [field] }
NULL: Length
NULL: Debug
NULL: Log
[Property] T { <Property> type [def] [product] }
NULL: Name
[Property] serializedEnumNames { <Property> declaration [field] }
[OnAfterDeserialize] enumNames { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] sets { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] enumNames { <OnAfterDeserialize> declaration [local] }
NULL: Length
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] enumNames { <OnAfterDeserialize> declaration [local] }
NULL: Length
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[{] currentValue { <{> declaration [local] }
NULL: MathUtils
NULL: HasFlag
[Property] properties { <Property> declaration [field] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[{] currentName { <{> declaration [local] }
[OnAfterDeserialize] enumNames { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[Property] serializedEnumNames { <Property> declaration [field] }
NULL: Length
[{] currentName { <{> declaration [local] }
[Property] serializedEnumNames { <Property> declaration [field] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[{] findOldIndex { <{> declaration [local] }
[{] oldIndex { <{> declaration [local] }
[{] oldIndex { <{> declaration [local] }
[Property] serializedEnumNames { <Property> declaration [field] }
NULL: Length
[{] oldIndex { <{> declaration [local] }
[Property] serializedEnumNames { <Property> declaration [field] }
[{] oldIndex { <{> declaration [local] }
[{] currentName { <{> declaration [local] }
[{] currentValue { <{> declaration [local] }
NULL: MathUtils
NULL: HasFlag
[Property] properties { <Property> declaration [field] }
[{] oldIndex { <{> declaration [local] }
[{] findOldIndex { <{> declaration [local] }
[{] currentValue { <{> declaration [local] }
NULL: Debug
NULL: Log
[Property] serializedEnumNames { <Property> declaration [field] }
[{] oldIndex { <{> declaration [local] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[{] findOldIndex { <{> declaration [local] }
[{] msg { <{> declaration [local] }
[{] currentName { <{> declaration [local] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[Property] serializedEnumNames { <Property> declaration [field] }
NULL: Length
[{] msg { <{> declaration [local] }
[Property] serializedEnumNames { <Property> declaration [field] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[{] currentValue { <{> declaration [local] }
NULL: Debug
NULL: LogWarning
[{] msg { <{> declaration [local] }
NULL: Debug
NULL: Log
[{] msg { <{> declaration [local] }
[{] currentValue { <{> declaration [local] }
[OnAfterDeserialize] sets { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[{] currentValue { <{> declaration [local] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] sets { <OnAfterDeserialize> declaration [local] }
NULL: Length
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[Property] properties { <Property> declaration [field] }
NULL: MathUtils
NULL: SetFlag
[Property] properties { <Property> declaration [field] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] sets { <OnAfterDeserialize> declaration [local] }
[OnAfterDeserialize] i { <OnAfterDeserialize> declaration [local] }
[Property] serializedEnumNames { <Property> declaration [field] }
[OnAfterDeserialize] enumNames { <OnAfterDeserialize> declaration [local] }
NULL: System
NULL: Serializable
[NULL] RangedInt { type [def] [product] }
NULL: Tooltip
[RangedInt] min { <RangedInt> declaration [field] }
NULL: Tooltip
[RangedInt] max { <RangedInt> declaration [field] }
[RangedInt] RangedInt { <RangedInt> constructor [def] }
[RangedInt] min { <RangedInt> declaration [argument] }
[RangedInt] max { <RangedInt> declaration [argument] }
[RangedInt] min { <RangedInt> declaration [field] }
[RangedInt] min { <RangedInt> declaration [argument] }
[RangedInt] max { <RangedInt> declaration [field] }
[RangedInt] max { <RangedInt> declaration [argument] }
[RangedInt] randomValue { <RangedInt> declaration [property] }
NULL: Random
NULL: Range
[RangedInt] min { <RangedInt> declaration [field] }
[RangedInt] max { <RangedInt> declaration [field] }
NULL: System
NULL: Serializable
[NULL] RangedFloat { type [def] [product] }
NULL: Tooltip
[RangedFloat] min { <RangedFloat> declaration [field] }
NULL: Tooltip
[RangedFloat] max { <RangedFloat> declaration [field] }
[RangedFloat] RangedFloat { <RangedFloat> constructor [def] }
[RangedFloat] min { <RangedFloat> declaration [argument] }
[RangedFloat] max { <RangedFloat> declaration [argument] }
[RangedFloat] min { <RangedFloat> declaration [field] }
[RangedFloat] min { <RangedFloat> declaration [argument] }
[RangedFloat] max { <RangedFloat> declaration [field] }
[RangedFloat] max { <RangedFloat> declaration [argument] }
[RangedFloat] randomValue { <RangedFloat> declaration [property] }
[randomValue] get { <randomValue> getter [def] }
[RangedFloat] min { <RangedFloat> declaration [field] }
[RangedFloat] max { <RangedFloat> declaration [field] }
[RangedFloat] min { <RangedFloat> declaration [field] }
NULL: Random
NULL: Range
[RangedFloat] min { <RangedFloat> declaration [field] }
[RangedFloat] max { <RangedFloat> declaration [field] }
[RangedFloat] range { <RangedFloat> declaration [property] }
[RangedFloat] max { <RangedFloat> declaration [field] }
[RangedFloat] min { <RangedFloat> declaration [field] }
NULL: System
NULL: Serializable
[NULL] IntReference { type [def] [product] }
[IntReference] useConstant { <IntReference> declaration [field] }
[IntReference] constantValue { <IntReference> declaration [field] }
NULL: IntVariable
[IntReference] variable { <IntReference> declaration [field] }
[IntReference] value { <IntReference> declaration [property] }
[value] get { <value> getter [def] }
[IntReference] useConstant { <IntReference> declaration [field] }
[IntReference] constantValue { <IntReference> declaration [field] }
[IntReference] variable { <IntReference> declaration [field] }
NULL: value
[value] set { <value> setter [def] }
[IntReference] useConstant { <IntReference> declaration [field] }
[IntReference] constantValue { <IntReference> declaration [field] }
[IntReference] value { <IntReference> declaration [property] }
[IntReference] variable { <IntReference> declaration [field] }
NULL: value
[IntReference] value { <IntReference> declaration [property] }
[IntReference] IntReference { <IntReference> constructor [def] }
[IntReference] value { <IntReference> declaration [argument] }
[IntReference] useConstant { <IntReference> declaration [field] }
[IntReference] constantValue { <IntReference> declaration [field] }
[IntReference] value { <IntReference> declaration [argument] }
[NULL] IntReference { type [def] [product] }
[int] reference { <int> declaration [argument] }
[int] reference { <int> declaration [argument] }
[IntReference] value { <IntReference> declaration [property] }
NULL: System
NULL: System
NULL: Collections
NULL: Generic
NULL: UnityEngine
NULL: Edgar
NULL: Unity
NULL: UnityEngine
NULL: Tilemaps
NULL: StringBuilder
NULL: System
NULL: Text
NULL: StringBuilder
[NULL] GameMode { type [def] [product] }
[GameMode] None { <GameMode> constant }
[GameMode] Quit { <GameMode> constant }
[GameMode] Main { <GameMode> constant }
[GameMode] Play { <GameMode> constant }
[GameMode] Count { <GameMode> constant }
NULL: SomethingHere
[NULL] GameManager { type [def] [product] }
NULL: MonoBehaviour
NULL: Header
[NULL] GameMode { type [def] [product] }
[GameManager] startMode { <GameManager> declaration [field] }
NULL: GameObject
[GameManager] mainMode { <GameManager> declaration [field] }
NULL: GameObject
[GameManager] playMode { <GameManager> declaration [field] }
NULL: LevelData
[GameManager] levels { <GameManager> declaration [field] }
[GameManager] currentLevel { <GameManager> declaration [field] }
NULL: Header
NULL: Vector3Variable
[GameManager] playerPos { <GameManager> declaration [field] }
[NULL] Entity { type [def] [product] }
[GameManager] cameraEntity { <GameManager> declaration [field] }
NULL: Header
[GameManager] overrideGameUI { <GameManager> declaration [field] }
NULL: GameMenu
[GameManager] gameMenu { <GameManager> declaration [field] }
NULL: Header
NULL: Audio
[GameManager] audios { <GameManager> declaration [field] }
NULL: AudioType
[GameManager] firstMusic { <GameManager> declaration [field] }
[GameManager] sourceCount { <GameManager> declaration [field] }
NULL: Pool
[GameManager] pools { <GameManager> declaration [field] }
NULL: List
NULL: RoomInstance
[GameManager] rooms { <GameManager> declaration [field] }
[GameManager] currentRoom { <GameManager> declaration [field] }
[NULL] Entity { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: Camera
[GameManager] mainCam { <GameManager> declaration [field] }
NULL: GameUI
[GameManager] gameUI { <GameManager> declaration [field] }
[GameManager] Bounds { <GameManager> type [def] [product] }
[GameManager] defaultBounds { <GameManager> declaration [field] }
NULL: Tilemap
[GameManager] tilemap { <GameManager> declaration [field] }
NULL: NewLine
NULL: SomeOtherThing
NULL: Multiple
NULL: System
NULL: Serializable
NULL: System
NULL: OtherCrap
[GameManager] Bounds { <GameManager> type [def] [product] }
[Bounds] a { <Bounds> declaration [field] }
[Bounds] b { <Bounds> declaration [field] }
[Bounds] c { <Bounds> declaration [field] }
NULL: UNITY_EDITOR
NULL: EasyButtons
NULL: Button
[GameManager] FindAllEntityProperties { <GameManager> function [def] }
[FindAllEntityProperties] generateFile { <FindAllEntityProperties> declaration [argument] }
[FindAllEntityProperties] watch { <FindAllEntityProperties> declaration [local] }
NULL: System
NULL: Diagnostics
NULL: Stopwatch
[FindAllEntityProperties] watch { <FindAllEntityProperties> declaration [local] }
NULL: Start
NULL: StringBuilder
[FindAllEntityProperties] builder { <FindAllEntityProperties> declaration [local] }
NULL: StringBuilder
NULL: DateTime
NULL: Now
NULL: ToString
[FindAllEntityProperties] SaveEntityProperties { <FindAllEntityProperties> function [def] }
[FindAllEntityProperties] builder { <FindAllEntityProperties> declaration [local] }
[] assets { <> declaration [local] }
NULL: UnityEditor
NULL: AssetDatabase
NULL: FindAssets
NULL: List
[NULL] Entity { type [def] [product] }
[] entities { <> declaration [local] }
NULL: List
[NULL] Entity { type [def] [product] }
[] assets { <> declaration [local] }
NULL: Length
[] asset { <> declaration [local] }
[] assets { <> declaration [local] }
[{] path { <{> declaration [local] }
NULL: UnityEditor
NULL: AssetDatabase
NULL: GUIDToAssetPath
[] asset { <> declaration [local] }
[NULL] Entity { type [def] [product] }
[{] entity { <{> declaration [local] }
NULL: UnityEditor
NULL: AssetDatabase
NULL: LoadAssetAtPath
[NULL] Entity { type [def] [product] }
[{] path { <{> declaration [local] }
[{] entity { <{> declaration [local] }
[] entities { <> declaration [local] }
NULL: Add
[{] entity { <{> declaration [local] }
[] entities { <> declaration [local] }
[FindAllEntityProperties] SaveEntityProperties { <FindAllEntityProperties> function [def] }
[FindAllEntityProperties] builder { <FindAllEntityProperties> declaration [local] }
[NULL] Entity { type [def] [product] }
[] assets { <> declaration [local] }
NULL: FindObjectsOfType
[NULL] Entity { type [def] [product] }
NULL: List
[NULL] Entity { type [def] [product] }
[] entities { <> declaration [local] }
NULL: List
[NULL] Entity { type [def] [product] }
[] assets { <> declaration [local] }
NULL: Length
[] entities { <> declaration [local] }
NULL: AddRange
[] assets { <> declaration [local] }
[] entities { <> declaration [local] }
[FindAllEntityProperties] message { <FindAllEntityProperties> declaration [local] }
NULL: UnityEngine
NULL: Object
[FindAllEntityProperties] context { <FindAllEntityProperties> declaration [local] }
[FindAllEntityProperties] generateFile { <FindAllEntityProperties> declaration [argument] }
[{] path { <{> declaration [local] }
NULL: GameUtils
NULL: CreateUniquePath
NULL: System
NULL: IO
NULL: File
NULL: WriteAllText
[{] path { <{> declaration [local] }
[FindAllEntityProperties] builder { <FindAllEntityProperties> declaration [local] }
NULL: ToString
NULL: UnityEditor
NULL: AssetDatabase
NULL: SaveAssets
NULL: UnityEditor
NULL: AssetDatabase
NULL: Refresh
[FindAllEntityProperties] message { <FindAllEntityProperties> declaration [local] }
[{] path { <{> declaration [local] }
[FindAllEntityProperties] context { <FindAllEntityProperties> declaration [local] }
NULL: UnityEditor
NULL: AssetDatabase
NULL: LoadAssetAtPath
NULL: TextAsset
[{] path { <{> declaration [local] }
[FindAllEntityProperties] watch { <FindAllEntityProperties> declaration [local] }
NULL: Stop
NULL: Debug
NULL: Log
[FindAllEntityProperties] message { <FindAllEntityProperties> declaration [local] }
[FindAllEntityProperties] context { <FindAllEntityProperties> declaration [local] }
[FindAllEntityProperties] SaveEntityProperties { <FindAllEntityProperties> function [def] }
NULL: StringBuilder
[SaveEntityProperties] builder { <SaveEntityProperties> declaration [argument] }
[SaveEntityProperties] title { <SaveEntityProperties> declaration [argument] }
NULL: Func
NULL: List
[NULL] Entity { type [def] [product] }
[SaveEntityProperties] getEntities { <SaveEntityProperties> declaration [argument] }
NULL: List
[NULL] Entity { type [def] [product] }
[SaveEntityProperties] entities { <SaveEntityProperties> declaration [local] }
[SaveEntityProperties] getEntities { <SaveEntityProperties> declaration [argument] }
[SaveEntityProperties] entities { <SaveEntityProperties> declaration [local] }
NULL: Insert
[SaveEntityProperties] builder { <SaveEntityProperties> declaration [argument] }
NULL: Append
[NULL] Entity { type [def] [product] }
[SaveEntityProperties] entity { <SaveEntityProperties> declaration [local] }
[SaveEntityProperties] entities { <SaveEntityProperties> declaration [local] }
[{] startIndex { <{> declaration [local] }
[SaveEntityProperties] builder { <SaveEntityProperties> declaration [argument] }
NULL: Length
[SaveEntityProperties] entity { <SaveEntityProperties> declaration [local] }
[SaveEntityProperties] builder { <SaveEntityProperties> declaration [argument] }
NULL: Append
[FindAllEntityProperties] SerializeType { <FindAllEntityProperties> function [def] }
[SaveEntityProperties] entity { <SaveEntityProperties> declaration [local] }
[SaveEntityProperties] builder { <SaveEntityProperties> declaration [argument] }
NULL: Debug
NULL: Log
[SaveEntityProperties] builder { <SaveEntityProperties> declaration [argument] }
NULL: ToString
[{] startIndex { <{> declaration [local] }
[SaveEntityProperties] builder { <SaveEntityProperties> declaration [argument] }
NULL: Length
[{] startIndex { <{> declaration [local] }
[SaveEntityProperties] entity { <SaveEntityProperties> declaration [local] }
NULL: gameObject
[SaveEntityProperties] builder { <SaveEntityProperties> declaration [argument] }
NULL: Append
[FindAllEntityProperties] PrintProperty { <FindAllEntityProperties> function [def] }
[PrintProperty] obj { <PrintProperty> declaration [argument] }
[PrintProperty] fieldName { <PrintProperty> declaration [argument] }
NULL: StringBuilder
[PrintProperty] builder { <PrintProperty> declaration [argument] }
[PrintProperty] indentLevel { <PrintProperty> declaration [argument] }
[PrintProperty] property { <PrintProperty> declaration [local] }
NULL: GameUtils
NULL: GetValueFromObject
[PrintProperty] obj { <PrintProperty> declaration [argument] }
[PrintProperty] names { <PrintProperty> declaration [local] }
NULL: GameUtils
NULL: GetValueFromObject
[PrintProperty] obj { <PrintProperty> declaration [argument] }
[PrintProperty] builder { <PrintProperty> declaration [argument] }
NULL: AppendIndentLine
[PrintProperty] fieldName { <PrintProperty> declaration [argument] }
[PrintProperty] indentLevel { <PrintProperty> declaration [argument] }
[PrintProperty] builder { <PrintProperty> declaration [argument] }
NULL: AppendIndentFormat
[PrintProperty] indentLevel { <PrintProperty> declaration [argument] }
[PrintProperty] fieldName { <PrintProperty> declaration [argument] }
NULL: Append
[PrintProperty] property { <PrintProperty> declaration [local] }
NULL: ToString
NULL: Append
NULL: AppendLine
NULL: Convert
NULL: ToString
[PrintProperty] property { <PrintProperty> declaration [local] }
NULL: List
[PrintProperty] setNames { <PrintProperty> declaration [local] }
NULL: List
[PrintProperty] names { <PrintProperty> declaration [local] }
NULL: Length
[PrintProperty] i { <PrintProperty> declaration [local] }
[PrintProperty] i { <PrintProperty> declaration [local] }
[PrintProperty] names { <PrintProperty> declaration [local] }
NULL: Length
[PrintProperty] i { <PrintProperty> declaration [local] }
NULL: MathUtils
NULL: HasFlag
[PrintProperty] property { <PrintProperty> declaration [local] }
[PrintProperty] i { <PrintProperty> declaration [local] }
[PrintProperty] setNames { <PrintProperty> declaration [local] }
NULL: Add
[PrintProperty] names { <PrintProperty> declaration [local] }
[PrintProperty] i { <PrintProperty> declaration [local] }
NULL: GameUtils
NULL: GetAllString
[PrintProperty] setNames { <PrintProperty> declaration [local] }
[PrintProperty] indentLevel { <PrintProperty> declaration [argument] }
[PrintProperty] builder { <PrintProperty> declaration [argument] }
[PrintProperty] builder { <PrintProperty> declaration [argument] }
NULL: GameUtils
NULL: GetAllString
[PrintProperty] names { <PrintProperty> declaration [local] }
[PrintProperty] indentLevel { <PrintProperty> declaration [argument] }
NULL: toString
[] name { <> declaration [argument] }
[] i { <> declaration [argument] }
[] name { <> declaration [argument] }
NULL: MathUtils
NULL: HasFlag
[PrintProperty] property { <PrintProperty> declaration [local] }
[] i { <> declaration [argument] }
[PrintProperty] builder { <PrintProperty> declaration [argument] }
[PrintProperty] builder { <PrintProperty> declaration [argument] }
[FindAllEntityProperties] SerializeType { <FindAllEntityProperties> function [def] }
[SerializeType] obj { <SerializeType> declaration [argument] }
NULL: StringBuilder
[SerializeType] builder { <SerializeType> declaration [argument] }
[SerializeType] fieldName { <SerializeType> declaration [argument] }
NULL: GameUtils
NULL: SerializeType
[SerializeType] obj { <SerializeType> declaration [argument] }
[] data { <> declaration [argument] }
[] data { <> declaration [argument] }
NULL: type
NULL: IsGenericType
[] data { <> declaration [argument] }
NULL: type
NULL: GetGenericTypeDefinition
[NULL] Property { type [def] [product] }
[] data { <> declaration [argument] }
[] property { <> declaration [local] }
[] data { <> declaration [argument] }
NULL: objs
[] name { <> declaration [local] }
[SerializeType] fieldName { <SerializeType> declaration [argument] }
[] data { <> declaration [argument] }
NULL: parent
NULL: parent
[{] isArrayElement { <{> declaration [local] }
[] data { <> declaration [argument] }
NULL: parent
NULL: type
NULL: IsArray
[{] isParentArrayElement { <{> declaration [local] }
[] data { <> declaration [argument] }
NULL: parent
NULL: parent
NULL: type
NULL: IsArray
NULL: Debug
NULL: Assert
[{] isArrayElement { <{> declaration [local] }
[{] isParentArrayElement { <{> declaration [local] }
[{] isParentArrayElement { <{> declaration [local] }
[] data { <> declaration [argument] }
[] data { <> declaration [argument] }
NULL: parent
[] name { <> declaration [local] }
[] data { <> declaration [argument] }
NULL: parent
NULL: field
NULL: Name
[{] isArrayElement { <{> declaration [local] }
[{] isParentArrayElement { <{> declaration [local] }
[] name { <> declaration [local] }
[FindAllEntityProperties] PrintProperty { <FindAllEntityProperties> function [def] }
[] property { <> declaration [local] }
[] name { <> declaration [local] }
[SerializeType] builder { <SerializeType> declaration [argument] }
[] data { <> declaration [argument] }
NULL: parent
NULL: depth
[] data { <> declaration [argument] }
[] data { <> declaration [argument] }
NULL: type
NULL: GameUtils
NULL: IsSerializableType
[] data { <> declaration [argument] }
NULL: type
[] data { <> declaration [argument] }
[] recursive { <> declaration [argument] }
[] recursive { <> declaration [argument] }
[GameManager] InitTilemap { <GameManager> function [def] }
NULL: List
NULL: RoomInstance
[InitTilemap] rooms { <InitTilemap> declaration [argument] }
NULL: Tilemap
[InitTilemap] tilemap { <InitTilemap> declaration [argument] }
NULL: TileBase
[InitTilemap] ruleTile { <InitTilemap> declaration [argument] }
[InitTilemap] room { <InitTilemap> declaration [local] }
[InitTilemap] rooms { <InitTilemap> declaration [argument] }
[{] door { <{> declaration [local] }
[InitTilemap] room { <InitTilemap> declaration [local] }
NULL: Doors
[{] door { <{> declaration [local] }
NULL: ConnectedRoomInstance
NULL: Vector3Int
[{] dir { <{> declaration [local] }
[{] door { <{> declaration [local] }
NULL: DoorLine
NULL: GetDirectionVector
[InitTilemap] tilemap { <InitTilemap> declaration [argument] }
NULL: SetTile
[{] door { <{> declaration [local] }
NULL: DoorLine
NULL: From
[InitTilemap] room { <InitTilemap> declaration [local] }
NULL: Position
[{] dir { <{> declaration [local] }
[InitTilemap] ruleTile { <InitTilemap> declaration [argument] }
[InitTilemap] tilemap { <InitTilemap> declaration [argument] }
NULL: SetTile
[{] door { <{> declaration [local] }
NULL: DoorLine
NULL: To
[InitTilemap] room { <InitTilemap> declaration [local] }
NULL: Position
[{] dir { <{> declaration [local] }
[InitTilemap] ruleTile { <InitTilemap> declaration [argument] }
NULL: Vector3Int
[{] doorTile { <{> declaration [local] }
[{] door { <{> declaration [local] }
NULL: DoorLine
NULL: GetPoints
NULL: Vector3Int
[{] pos { <{> declaration [local] }
[{] doorTile { <{> declaration [local] }
[InitTilemap] room { <InitTilemap> declaration [local] }
NULL: Position
[InitTilemap] tilemap { <InitTilemap> declaration [argument] }
NULL: SetTile
[{] pos { <{> declaration [local] }
[{] Remove { <{> function [def] }
[InitTilemap] tilemap { <InitTilemap> declaration [argument] }
[{] pos { <{> declaration [local] }
NULL: Vector3Int
[{] door { <{> declaration [local] }
NULL: FacingDirection
[{] Remove { <{> function [def] }
NULL: Tilemap
[Remove] tilemap { <Remove> declaration [argument] }
NULL: Vector3Int
[Remove] pos { <Remove> declaration [argument] }
NULL: Vector3Int
[Remove] removeDir { <Remove> declaration [argument] }
[Remove] pos { <Remove> declaration [argument] }
[Remove] removeDir { <Remove> declaration [argument] }
[Remove] tilemap { <Remove> declaration [argument] }
NULL: GetTile
[Remove] pos { <Remove> declaration [argument] }
[Remove] tilemap { <Remove> declaration [argument] }
NULL: SetTile
[Remove] pos { <Remove> declaration [argument] }
[{] Remove { <{> function [def] }
[Remove] tilemap { <Remove> declaration [argument] }
[Remove] pos { <Remove> declaration [argument] }
[Remove] removeDir { <Remove> declaration [argument] }
[InitTilemap] tilemap { <InitTilemap> declaration [argument] }
NULL: CompressAndRefresh
[GameManager] rooms { <GameManager> declaration [field] }
[InitTilemap] rooms { <InitTilemap> declaration [argument] }
[NULL] GameManager { type [def] [product] }
[GameManager] tilemap { <GameManager> declaration [field] }
[InitTilemap] tilemap { <InitTilemap> declaration [argument] }
NULL: Debug
NULL: Log
[InitTilemap] tilemap { <InitTilemap> declaration [argument] }
NULL: Tilemap
[GameManager] GetTilemapFromRoom { <GameManager> function [def] }
NULL: Transform
[GetTilemapFromRoom] roomTransform { <GetTilemapFromRoom> declaration [argument] }
[GetTilemapFromRoom] roomTransform { <GetTilemapFromRoom> declaration [argument] }
NULL: GetChild
NULL: GetChild
NULL: GetComponent
NULL: Tilemap
[GameManager] Bounds { <GameManager> type [def] [product] }
[GameManager] GetBoundsFromTilemap { <GameManager> function [def] }
NULL: Tilemap
[GetBoundsFromTilemap] tilemap { <GetBoundsFromTilemap> declaration [argument] }
[GameManager] Bounds { <GameManager> type [def] [product] }
[GetBoundsFromTilemap] bounds { <GetBoundsFromTilemap> declaration [local] }
[GetBoundsFromTilemap] tilemap { <GetBoundsFromTilemap> declaration [argument] }
NULL: cellBounds
NULL: ToBounds
[GetBoundsFromTilemap] bounds { <GetBoundsFromTilemap> declaration [local] }
NULL: center
[GetBoundsFromTilemap] tilemap { <GetBoundsFromTilemap> declaration [argument] }
NULL: transform
NULL: position
[GetBoundsFromTilemap] bounds { <GetBoundsFromTilemap> declaration [local] }
[GameManager] Bounds { <GameManager> type [def] [product] }
[GameManager] GetBoundsFromRoom { <GameManager> function [def] }
NULL: Transform
[GetBoundsFromRoom] roomTransform { <GetBoundsFromRoom> declaration [argument] }
[GetBoundsFromRoom] roomTransform { <GetBoundsFromRoom> declaration [argument] }
[GameManager] GetBoundsFromTilemap { <GameManager> function [def] }
[GameManager] GetTilemapFromRoom { <GameManager> function [def] }
[GetBoundsFromRoom] roomTransform { <GetBoundsFromRoom> declaration [argument] }
[GameManager] defaultBounds { <GameManager> declaration [field] }
[GameManager] GetGroundPos { <GameManager> function [def] }
[NULL] Vector2 { type [def] [product] }
[GetGroundPos] pos { <GetGroundPos> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[GetGroundPos] extents { <GetGroundPos> declaration [argument] }
[GetGroundPos] dirY { <GetGroundPos> declaration [argument] }
NULL: Vector3Int
[GetGroundPos] groundPos { <GetGroundPos> declaration [argument] }
NULL: Vector3Int
[GetGroundPos] emptyPos { <GetGroundPos> declaration [argument] }
NULL: RaycastHit2D
[GetGroundPos] hitInfo { <GetGroundPos> declaration [local] }
NULL: GameUtils
NULL: GroundCheck
[GetGroundPos] pos { <GetGroundPos> declaration [argument] }
[GetGroundPos] extents { <GetGroundPos> declaration [argument] }
[GetGroundPos] dirY { <GetGroundPos> declaration [argument] }
NULL: Color
NULL: cyan
[GetGroundPos] groundPos { <GetGroundPos> declaration [argument] }
NULL: Vector3Int
NULL: zero
[GetGroundPos] emptyPos { <GetGroundPos> declaration [argument] }
NULL: Vector3Int
NULL: zero
[GetGroundPos] hitInfo { <GetGroundPos> declaration [local] }
NULL: Vector3Int
[{] hitPosCeil { <{> declaration [local] }
[GameManager] QueryTiles { <GameManager> function [def] }
[GameManager] tilemap { <GameManager> declaration [field] }
[GetGroundPos] hitInfo { <GetGroundPos> declaration [local] }
NULL: point
NULL: ToVector2Int
NULL: ToVector3Int
[GetGroundPos] dirY { <GetGroundPos> declaration [argument] }
NULL: Vector3Int
[{] hitPosFloor { <{> declaration [local] }
[GameManager] QueryTiles { <GameManager> function [def] }
[GameManager] tilemap { <GameManager> declaration [field] }
[GetGroundPos] hitInfo { <GetGroundPos> declaration [local] }
NULL: point
NULL: ToVector2Int
NULL: ToVector3Int
[GetGroundPos] dirY { <GetGroundPos> declaration [argument] }
[GetGroundPos] groundPos { <GetGroundPos> declaration [argument] }
NULL: Mathf
NULL: Abs
[{] hitPosFloor { <{> declaration [local] }
NULL: y
[GetGroundPos] hitInfo { <GetGroundPos> declaration [local] }
NULL: point
NULL: y
NULL: Mathf
NULL: Abs
[{] hitPosCeil { <{> declaration [local] }
NULL: y
[GetGroundPos] hitInfo { <GetGroundPos> declaration [local] }
NULL: point
NULL: y
[{] hitPosFloor { <{> declaration [local] }
[{] hitPosCeil { <{> declaration [local] }
[GetGroundPos] emptyPos { <GetGroundPos> declaration [argument] }
[GetGroundPos] groundPos { <GetGroundPos> declaration [argument] }
NULL: Vector3Int
[GetGroundPos] dirY { <GetGroundPos> declaration [argument] }
[GetGroundPos] hitInfo { <GetGroundPos> declaration [local] }
NULL: Rect
[GameManager] CalculateMoveRegion { <GameManager> function [def] }
[NULL] Vector2 { type [def] [product] }
[CalculateMoveRegion] pos { <CalculateMoveRegion> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[CalculateMoveRegion] extents { <CalculateMoveRegion> declaration [argument] }
[CalculateMoveRegion] dirY { <CalculateMoveRegion> declaration [argument] }
NULL: Rect
[CalculateMoveRegion] result { <CalculateMoveRegion> declaration [local] }
NULL: Rect
NULL: Debug
NULL: Assert
[CalculateMoveRegion] dirY { <CalculateMoveRegion> declaration [argument] }
NULL: Mathf
NULL: Sign
[CalculateMoveRegion] dirY { <CalculateMoveRegion> declaration [argument] }
[CalculateMoveRegion] dirY { <CalculateMoveRegion> declaration [argument] }
[GameManager] GetGroundPos { <GameManager> function [def] }
[CalculateMoveRegion] pos { <CalculateMoveRegion> declaration [argument] }
[CalculateMoveRegion] extents { <CalculateMoveRegion> declaration [argument] }
[CalculateMoveRegion] dirY { <CalculateMoveRegion> declaration [argument] }
NULL: Vector3Int
[CalculateMoveRegion] hitPos { <CalculateMoveRegion> declaration [local] }
NULL: notDecl
NULL: Vector3Int
[CalculateMoveRegion] empPos { <CalculateMoveRegion> declaration [local] }
NULL: Vector3Int
[{] minGroundPos { <{> declaration [local] }
[GameManager] QueryTiles { <GameManager> function [def] }
[GameManager] tilemap { <GameManager> declaration [field] }
[CalculateMoveRegion] hitPos { <CalculateMoveRegion> declaration [local] }
NULL: Vector3Int
[{] maxGroundPos { <{> declaration [local] }
[GameManager] QueryTiles { <GameManager> function [def] }
[GameManager] tilemap { <GameManager> declaration [field] }
[CalculateMoveRegion] hitPos { <CalculateMoveRegion> declaration [local] }
NULL: Vector3Int
[{] minWallPos { <{> declaration [local] }
[GameManager] QueryTiles { <GameManager> function [def] }
[GameManager] tilemap { <GameManager> declaration [field] }
[CalculateMoveRegion] empPos { <CalculateMoveRegion> declaration [local] }
NULL: Vector3Int
[{] maxWallPos { <{> declaration [local] }
[GameManager] QueryTiles { <GameManager> function [def] }
[GameManager] tilemap { <GameManager> declaration [field] }
[CalculateMoveRegion] empPos { <CalculateMoveRegion> declaration [local] }
[CalculateMoveRegion] dirY { <CalculateMoveRegion> declaration [argument] }
[{] minGroundPos { <{> declaration [local] }
NULL: y
[{] maxGroundPos { <{> declaration [local] }
NULL: y
[CalculateMoveRegion] dirY { <CalculateMoveRegion> declaration [argument] }
[{] minWallPos { <{> declaration [local] }
NULL: y
[{] maxWallPos { <{> declaration [local] }
NULL: y
[NULL] Vector2 { type [def] [product] }
[{] minPos { <{> declaration [local] }
NULL: MathUtils
NULL: Max
NULL: Vector2Int
[{] minGroundPos { <{> declaration [local] }
NULL: Vector2Int
[{] minWallPos { <{> declaration [local] }
[NULL] Vector2 { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
[{] maxPos { <{> declaration [local] }
NULL: MathUtils
NULL: Min
NULL: Vector2Int
[{] maxGroundPos { <{> declaration [local] }
NULL: Vector2Int
[{] maxWallPos { <{> declaration [local] }
[CalculateMoveRegion] result { <CalculateMoveRegion> declaration [local] }
NULL: MathUtils
NULL: CreateRectMinMax
[{] minPos { <{> declaration [local] }
[CalculateMoveRegion] extents { <CalculateMoveRegion> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[CalculateMoveRegion] dirY { <CalculateMoveRegion> declaration [argument] }
[{] maxPos { <{> declaration [local] }
[CalculateMoveRegion] extents { <CalculateMoveRegion> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[CalculateMoveRegion] dirY { <CalculateMoveRegion> declaration [argument] }
NULL: GameDebug
NULL: DrawBox
[CalculateMoveRegion] result { <CalculateMoveRegion> declaration [local] }
NULL: Color
NULL: green
NULL: GameDebug
NULL: DrawLine
NULL: Vector3
[{] minGroundPos { <{> declaration [local] }
NULL: Vector3
[{] maxGroundPos { <{> declaration [local] }
NULL: Color
NULL: red
NULL: GameDebug
NULL: DrawLine
NULL: Vector3
[{] minWallPos { <{> declaration [local] }
NULL: Vector3
[{] maxWallPos { <{> declaration [local] }
NULL: Color
NULL: yellow
[CalculateMoveRegion] result { <CalculateMoveRegion> declaration [local] }
NULL: Vector3Int
[GameManager] QueryTiles { <GameManager> function [def] }
NULL: Tilemap
[QueryTiles] tilemap { <QueryTiles> declaration [argument] }
NULL: Vector3Int
[QueryTiles] startPos { <QueryTiles> declaration [argument] }
[QueryTiles] breakCondition { <QueryTiles> declaration [argument] }
[QueryTiles] advanceX { <QueryTiles> declaration [argument] }
[QueryTiles] advanceY { <QueryTiles> declaration [argument] }
NULL: Vector3Int
[QueryTiles] pos { <QueryTiles> declaration [local] }
[QueryTiles] startPos { <QueryTiles> declaration [argument] }
[QueryTiles] tilemap { <QueryTiles> declaration [argument] }
NULL: GetTile
[QueryTiles] pos { <QueryTiles> declaration [local] }
[QueryTiles] breakCondition { <QueryTiles> declaration [argument] }
[QueryTiles] pos { <QueryTiles> declaration [local] }
NULL: Vector3Int
[QueryTiles] advanceX { <QueryTiles> declaration [argument] }
[QueryTiles] advanceY { <QueryTiles> declaration [argument] }
[QueryTiles] pos { <QueryTiles> declaration [local] }
[GameManager] Start { <GameManager> function [def] }
NULL: ObjectPooler
NULL: Init
NULL: gameObject
[GameManager] pools { <GameManager> declaration [field] }
NULL: AudioManager
NULL: Init
NULL: gameObject
[GameManager] audios { <GameManager> declaration [field] }
[GameManager] firstMusic { <GameManager> declaration [field] }
[GameManager] sourceCount { <GameManager> declaration [field] }
[GameManager] gameUI { <GameManager> declaration [field] }
NULL: FindObjectOfType
NULL: GameUI
[GameManager] mainCam { <GameManager> declaration [field] }
NULL: Camera
NULL: main
[GameManager] cameraEntity { <GameManager> declaration [field] }
[GameManager] mainCam { <GameManager> declaration [field] }
NULL: GetComponentInParent
[NULL] Entity { type [def] [product] }
[GameManager] StartGameMode { <GameManager> function [def] }
[GameManager] startMode { <GameManager> declaration [field] }
NULL: GameDebug
NULL: BindInput
NULL: DebugInput
NULL: trigger
NULL: InputType
NULL: Debug_CameraShake
NULL: increase
NULL: InputType
NULL: Debug_ShakeIncrease
NULL: decrease
NULL: InputType
NULL: Debug_ShakeDecrease
NULL: range
[NULL] RangedFloat { type [def] [product] }
NULL: Enum
NULL: GetValues
NULL: ShakeMode
NULL: Length
NULL: updateValue
[] value { <> declaration [argument] }
[] dir { <> declaration [argument] }
[] value { <> declaration [argument] }
[] dir { <> declaration [argument] }
NULL: callback
[] mode { <> declaration [argument] }
NULL: GameDebug
NULL: Log
NULL: ShakeMode
[] mode { <> declaration [argument] }
NULL: CameraSystem
NULL: instance
NULL: Shake
NULL: ShakeMode
[] mode { <> declaration [argument] }
NULL: MathUtils
NULL: SmoothStart3
NULL: GameDebug
NULL: BindInput
NULL: InputType
NULL: Debug_CameraShock
NULL: CameraSystem
NULL: instance
NULL: Shock
NULL: GameDebug
NULL: BindInput
NULL: InputType
NULL: Debug_ToggleLog
NULL: GameDebug
NULL: ToggleLogger
NULL: GameDebug
NULL: BindInput
NULL: InputType
NULL: Debug_ClearLog
NULL: GameDebug
NULL: ClearLog
NULL: GameDebug
NULL: BindInput
NULL: DebugInput
NULL: trigger
NULL: InputType
NULL: Debug_ResetTime
NULL: increase
NULL: InputType
NULL: Debug_FastTime
NULL: decrease
NULL: InputType
NULL: Debug_SlowTime
NULL: value
NULL: f
NULL: range
[NULL] RangedFloat { type [def] [product] }
NULL: f
NULL: updateValue
[] value { <> declaration [argument] }
[] dir { <> declaration [argument] }
[] value { <> declaration [argument] }
NULL: Mathf
NULL: Pow
[] dir { <> declaration [argument] }
NULL: changed
[] scale { <> declaration [argument] }
NULL: Time
NULL: timeScale
[] scale { <> declaration [argument] }
NULL: GameDebug
NULL: Log
NULL: Time
NULL: timeScale
NULL: callback
[] _ { <> declaration [argument] }
NULL: Time
NULL: timeScale
NULL: GameDebug
NULL: Log
NULL: GameDebug
NULL: BindInput
NULL: InputType
NULL: Debug_SpawnParticle
NULL: ParticleEffect
NULL: instance
NULL: SpawnParticle
NULL: ParticleType
NULL: Explosion
[NULL] Vector2 { type [def] [product] }
NULL: zero
NULL: GameDebug
NULL: BindInput
NULL: InputType
NULL: Debug_TestPlayerVFX
[GameManager] player { <GameManager> declaration [field] }
[Entity] TestPlayerVFX { <Entity> function [def] }
[GameManager] Update { <GameManager> function [def] }
NULL: GameDebug
NULL: UpdateInput
[GameManager] rooms { <GameManager> declaration [field] }
[GameManager] levels { <GameManager> declaration [field] }
[GameManager] currentLevel { <GameManager> declaration [field] }
NULL: moveAutomatically
[GameManager] cameraEntity { <GameManager> declaration [field] }
[Entity] CompleteCycle { <Entity> function [def] }
[GameManager] currentRoom { <GameManager> declaration [field] }
[GameManager] rooms { <GameManager> declaration [field] }
NULL: Count
[{] aspectRatio { <{> declaration [local] }
NULL: f
NULL: f
NULL: Transform
[{] roomTransform { <{> declaration [local] }
[GameManager] rooms { <GameManager> declaration [field] }
[GameManager] currentRoom { <GameManager> declaration [field] }
NULL: RoomTemplateInstance
NULL: transform
[GameManager] Bounds { <GameManager> type [def] [product] }
[{] bounds { <{> declaration [local] }
[GameManager] GetBoundsFromRoom { <GameManager> function [def] }
[{] roomTransform { <{> declaration [local] }
[{] ratio { <{> declaration [local] }
[{] bounds { <{> declaration [local] }
NULL: extents
NULL: x
[{] bounds { <{> declaration [local] }
NULL: extents
NULL: y
[GameManager] mainCam { <GameManager> declaration [field] }
NULL: orthographicSize
[{] ratio { <{> declaration [local] }
[{] aspectRatio { <{> declaration [local] }
[{] bounds { <{> declaration [local] }
NULL: extents
NULL: x
[{] aspectRatio { <{> declaration [local] }
[{] bounds { <{> declaration [local] }
NULL: extents
NULL: y
NULL: GameInput
NULL: TriggerEvent
NULL: GameEventType
NULL: NextRoom
[{] roomTransform { <{> declaration [local] }
[{] i { <{> declaration [local] }
[{] i { <{> declaration [local] }
[GameManager] rooms { <GameManager> declaration [field] }
NULL: Count
[{] i { <{> declaration [local] }
[{] i { <{> declaration [local] }
[GameManager] currentRoom { <GameManager> declaration [field] }
NULL: Rect
[{] roomRect { <{> declaration [local] }
[GameManager] GetBoundsFromRoom { <GameManager> function [def] }
[GameManager] rooms { <GameManager> declaration [field] }
[{] i { <{> declaration [local] }
NULL: RoomTemplateInstance
NULL: transform
NULL: ToRect
NULL: Resize
[NULL] Vector2 { type [def] [product] }
NULL: one
[NULL] Vector2 { type [def] [product] }
NULL: one
[{] roomRect { <{> declaration [local] }
NULL: Contains
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
NULL: position
NULL: GameInput
NULL: TriggerEvent
NULL: GameEventType
NULL: NextRoom
[GameManager] rooms { <GameManager> declaration [field] }
[{] i { <{> declaration [local] }
NULL: RoomTemplateInstance
NULL: transform
[GameManager] currentRoom { <GameManager> declaration [field] }
[{] i { <{> declaration [local] }
[GameManager] StartGameMode { <GameManager> function [def] }
[NULL] GameMode { type [def] [product] }
[StartGameMode] mode { <StartGameMode> declaration [argument] }
[StartGameMode] mode { <StartGameMode> declaration [argument] }
[NULL] GameMode { type [def] [product] }
[GameMode] None { <GameMode> constant }
[StartGameMode] mode { <StartGameMode> declaration [argument] }
[NULL] GameMode { type [def] [product] }
[GameMode] Count { <GameMode> constant }
[StartGameMode] mode { <StartGameMode> declaration [argument] }
[NULL] GameMode { type [def] [product] }
[GameMode] Quit { <GameMode> constant }
NULL: Application
NULL: Quit
[GameManager] rooms { <GameManager> declaration [field] }
NULL: Clear
[GameManager] gameMenu { <GameManager> declaration [field] }
NULL: gameObject
NULL: SetActive
[{] isMainMode { <{> declaration [local] }
[StartGameMode] mode { <StartGameMode> declaration [argument] }
[NULL] GameMode { type [def] [product] }
[GameMode] Main { <GameMode> constant }
[GameManager] mainMode { <GameManager> declaration [field] }
[GameManager] mainMode { <GameManager> declaration [field] }
NULL: SetActive
[{] isMainMode { <{> declaration [local] }
[GameManager] playMode { <GameManager> declaration [field] }
NULL: SetActive
[{] isMainMode { <{> declaration [local] }
[StartGameMode] mode { <StartGameMode> declaration [argument] }
[NULL] GameMode { type [def] [product] }
[GameMode] Main { <GameMode> constant }
NULL: AudioManager
NULL: PlayAudio
NULL: AudioType
NULL: Music_Main
[NULL] GameMode { type [def] [product] }
[GameMode] Play { <GameMode> constant }
[{] i { <{> declaration [local] }
[{] i { <{> declaration [local] }
[GameManager] levels { <GameManager> declaration [field] }
NULL: Length
[{] i { <{> declaration [local] }
[GameManager] levels { <GameManager> declaration [field] }
[{] i { <{> declaration [local] }
NULL: gameObject
NULL: SetActive
[{] i { <{> declaration [local] }
[GameManager] currentLevel { <GameManager> declaration [field] }
[GameManager] overrideGameUI { <GameManager> declaration [field] }
[GameManager] gameUI { <GameManager> declaration [field] }
NULL: displayHealthBar
[GameManager] gameUI { <GameManager> declaration [field] }
NULL: displayMoneyCount
[GameManager] gameUI { <GameManager> declaration [field] }
NULL: displayWaveCount
[GameManager] gameUI { <GameManager> declaration [field] }
NULL: displayWeaponUI
[GameManager] gameUI { <GameManager> declaration [field] }
NULL: enabled
[GameManager] levels { <GameManager> declaration [field] }
[GameManager] currentLevel { <GameManager> declaration [field] }
NULL: enableUI
[GameManager] gameUI { <GameManager> declaration [field] }
NULL: displayMinimap
[GameManager] levels { <GameManager> declaration [field] }
[GameManager] currentLevel { <GameManager> declaration [field] }
NULL: enableMinimap
NULL: LevelData
[{] level { <{> declaration [local] }
[GameManager] levels { <GameManager> declaration [field] }
[GameManager] currentLevel { <GameManager> declaration [field] }
[GameManager] cameraEntity { <GameManager> declaration [field] }
[Entity] properties { <Entity> declaration [field] }
NULL: SetProperty
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] CustomInit { <EntityProperty> constant }
[GameManager] cameraEntity { <GameManager> declaration [field] }
[Entity] CustomInit { <Entity> function [def] }
[GameManager] cameraEntity { <GameManager> declaration [field] }
[Entity] InitCamera { <Entity> function [def] }
[{] level { <{> declaration [local] }
NULL: moveAutomatically
[{] level { <{> declaration [local] }
NULL: useSmoothDamp
[{] level { <{> declaration [local] }
NULL: cameraValue
[{] level { <{> declaration [local] }
NULL: waitTime
[{] level { <{> declaration [local] }
NULL: type
NULL: BoundsType
NULL: Generator
[{] levelGenerated { <{> declaration [local] }
[{] count { <{> declaration [local] }
[{] level { <{> declaration [local] }
NULL: maxGenerateTry
NULL: DungeonGenerator
[{] generator { <{> declaration [local] }
[{] level { <{> declaration [local] }
NULL: generator
[{] generator { <{> declaration [local] }
NULL: transform
NULL: Clear
[{] levelGenerated { <{> declaration [local] }
[{] count { <{> declaration [local] }
NULL: Debug
NULL: LogError
[{] generator { <{> declaration [local] }
NULL: Generate
[{] levelGenerated { <{> declaration [local] }
NULL: InvalidOperationException
NULL: Debug
NULL: LogError
[{] count { <{> declaration [local] }
[{] level { <{> declaration [local] }
NULL: moveAutomatically
[GameManager] currentRoom { <GameManager> declaration [field] }
NULL: GameInput
NULL: BindEvent
NULL: GameEventType
NULL: EndRoom
[] room { <> declaration [argument] }
[GameManager] LockRoom { <GameManager> function [def] }
[] room { <> declaration [argument] }
NULL: GameInput
NULL: BindEvent
NULL: GameEventType
NULL: NextRoom
[] room { <> declaration [argument] }
[GameManager] LockRoom { <GameManager> function [def] }
[] room { <> declaration [argument] }
[{] level { <{> declaration [local] }
NULL: disableEnemies
[GameManager] currentRoom { <GameManager> declaration [field] }
NULL: PlayerController
[{] player { <{> declaration [local] }
NULL: FindObjectOfType
NULL: PlayerController
[{] player { <{> declaration [local] }
NULL: Destroy
[{] player { <{> declaration [local] }
NULL: gameObject
NULL: BoundsType
NULL: Tilemap
[GameManager] tilemap { <GameManager> declaration [field] }
[{] level { <{> declaration [local] }
NULL: tilemap
NULL: CompressAndRefresh
[GameManager] defaultBounds { <GameManager> declaration [field] }
[{] level { <{> declaration [local] }
NULL: tilemap
NULL: cellBounds
NULL: ToBounds
NULL: GameInput
NULL: TriggerEvent
NULL: GameEventType
NULL: NextRoom
NULL: BoundsType
NULL: Custom
[GameManager] defaultBounds { <GameManager> declaration [field] }
[GameManager] Bounds { <GameManager> type [def] [product] }
NULL: Vector3
NULL: zero
[{] level { <{> declaration [local] }
NULL: boundsSize
[GameManager] mainCam { <GameManager> declaration [field] }
NULL: HalfSize
NULL: GameInput
NULL: TriggerEvent
NULL: GameEventType
NULL: NextRoom
[GameManager] player { <GameManager> declaration [field] }
NULL: GameObject
NULL: FindGameObjectWithTag
NULL: GetComponent
[NULL] Entity { type [def] [product] }
[GameManager] LockRoom { <GameManager> function [def] }
NULL: Transform
[LockRoom] room { <LockRoom> declaration [argument] }
[LockRoom] lockRoom { <LockRoom> declaration [argument] }
[LockRoom] disableEnemies { <LockRoom> declaration [argument] }
[LockRoom] lockRoom { <LockRoom> declaration [argument] }
[LockRoom] disableEnemies { <LockRoom> declaration [argument] }
NULL: EnemySpawner
[{] spawner { <{> declaration [local] }
[LockRoom] room { <LockRoom> declaration [argument] }
NULL: GetComponentInChildren
NULL: EnemySpawner
[{] spawner { <{> declaration [local] }
[{] spawner { <{> declaration [local] }
NULL: enabled
NULL: Transform
[LockRoom] doorHolder { <LockRoom> declaration [local] }
[LockRoom] room { <LockRoom> declaration [argument] }
NULL: Find
[LockRoom] doorHolder { <LockRoom> declaration [local] }
[LockRoom] lockRoom { <LockRoom> declaration [argument] }
[LockRoom] doorHolder { <LockRoom> declaration [local] }
NULL: gameObject
NULL: SetActive
NULL: Destroy
[LockRoom] doorHolder { <LockRoom> declaration [local] }
NULL: gameObject
NULL: f
NULL: Transform
[{] door { <{> declaration [local] }
[LockRoom] doorHolder { <LockRoom> declaration [local] }
NULL: Animator
[{] doorAnim { <{> declaration [local] }
[{] door { <{> declaration [local] }
NULL: GetComponent
NULL: Animator
[{] doorAnim { <{> declaration [local] }
NULL: Play
[LockRoom] lockRoom { <LockRoom> declaration [argument] }
[GameManager] OnAudioFilterRead { <GameManager> function [def] }
[OnAudioFilterRead] data { <OnAudioFilterRead> declaration [argument] }
[OnAudioFilterRead] channels { <OnAudioFilterRead> declaration [argument] }
NULL: AudioManager
NULL: ReadAudio
[OnAudioFilterRead] data { <OnAudioFilterRead> declaration [argument] }
[OnAudioFilterRead] channels { <OnAudioFilterRead> declaration [argument] }
[NULL] SCRIPTABLE_VFX { macro }
NULL: System
NULL: Collections
NULL: UnityEngine
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] CanJump { <EntityProperty> constant }
[EntityProperty] CanBeHurt { <EntityProperty> constant }
[EntityProperty] DamageWhenCollide { <EntityProperty> constant }
[EntityProperty] DieWhenCollide { <EntityProperty> constant }
[EntityProperty] DieAfterMoveTime { <EntityProperty> constant }
[EntityProperty] SpawnCellWhenDie { <EntityProperty> constant }
[EntityProperty] SpawnDamagePopup { <EntityProperty> constant }
[EntityProperty] ClampToMoveRegion { <EntityProperty> constant }
[EntityProperty] StartAtMinMoveRegion { <EntityProperty> constant }
[EntityProperty] IsCritical { <EntityProperty> constant }
[EntityProperty] UsePooling { <EntityProperty> constant }
[EntityProperty] CustomInit { <EntityProperty> constant }
[EntityProperty] AddMoneyWhenCollide { <EntityProperty> constant }
[EntityProperty] FallingOnSpawn { <EntityProperty> constant }
[EntityProperty] IsGrounded { <EntityProperty> constant }
[EntityProperty] IsReloading { <EntityProperty> constant }
[EntityProperty] AtEndOfMoveRegion { <EntityProperty> constant }
[EntityProperty] Count { <EntityProperty> constant }
[NULL] EntityState { type [def] [product] }
[EntityState] None { <EntityState> constant }
[EntityState] Jumping { <EntityState> constant }
[EntityState] Falling { <EntityState> constant }
[EntityState] Landing { <EntityState> constant }
[EntityState] StartMoving { <EntityState> constant }
[EntityState] StopMoving { <EntityState> constant }
[EntityState] StartAttack { <EntityState> constant }
[EntityState] StartCooldown { <EntityState> constant }
[EntityState] OnSpawn { <EntityState> constant }
[EntityState] OnHit { <EntityState> constant }
[EntityState] OnDeath { <EntityState> constant }
NULL: SerializedPool
[NULL] Entity { type [def] [product] }
NULL: MonoBehaviour
NULL: IPooledObject
NULL: Ability
[Entity] AbilityType { <Entity> type [def] [product] }
[AbilityType] None { <AbilityType> constant }
[AbilityType] Move { <AbilityType> constant }
[AbilityType] Teleport { <AbilityType> constant }
[AbilityType] Explode { <AbilityType> constant }
[AbilityType] Jump { <AbilityType> constant }
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] Interuptible { <AbilityFlag> constant }
[AbilityFlag] AwayFromPlayer { <AbilityFlag> constant }
[AbilityFlag] LockOnPlayerForEternity { <AbilityFlag> constant }
[AbilityFlag] ExecuteWhenLowHealth { <AbilityFlag> constant }
[AbilityFlag] ExecuteWhenInRange { <AbilityFlag> constant }
[AbilityFlag] ExecuteWhenInRangeY { <AbilityFlag> constant }
[AbilityFlag] ExecuteWhenOutOfMoveRegion { <AbilityFlag> constant }
[AbilityFlag] OrCombine { <AbilityFlag> constant }
[AbilityFlag] CanExecute { <AbilityFlag> constant }
NULL: System
NULL: Serializable
[Entity] EntityAbility { <Entity> type [def] [product] }
[NULL] Property { type [def] [product] }
[Entity] AbilityFlag { <Entity> type [def] [product] }
[EntityAbility] flags { <EntityAbility> declaration [field] }
[Entity] EntityVFX { <Entity> type [def] [product] }
[EntityAbility] vfx { <EntityAbility> declaration [field] }
[Entity] AbilityType { <Entity> type [def] [product] }
[EntityAbility] type { <EntityAbility> declaration [field] }
[EntityAbility] healthToExecute { <EntityAbility> declaration [field] }
[EntityAbility] distanceToExecute { <EntityAbility> declaration [field] }
[EntityAbility] distanceToExecuteY { <EntityAbility> declaration [field] }
[EntityAbility] cooldownTime { <EntityAbility> declaration [field] }
[EntityAbility] interuptibleTime { <EntityAbility> declaration [field] }
[EntityAbility] chargeTime { <EntityAbility> declaration [field] }
[EntityAbility] duration { <EntityAbility> declaration [field] }
[EntityAbility] range { <EntityAbility> declaration [field] }
[EntityAbility] damage { <EntityAbility> declaration [field] }
[Entity] CanUseAbility { <Entity> function [def] }
[Entity] EntityAbility { <Entity> type [def] [product] }
[CanUseAbility] ability { <CanUseAbility> declaration [argument] }
[NULL] Property { type [def] [product] }
[Entity] AbilityFlag { <Entity> type [def] [product] }
[CanUseAbility] flags { <CanUseAbility> declaration [local] }
[CanUseAbility] ability { <CanUseAbility> declaration [argument] }
[EntityAbility] flags { <EntityAbility> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[CanUseAbility] pos { <CanUseAbility> declaration [local] }
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
NULL: position
NULL: transform
NULL: position
NULL: Vector3
NULL: one
[CanUseAbility] lowHealth { <CanUseAbility> declaration [local] }
[CanUseAbility] flags { <CanUseAbility> declaration [local] }
NULL: HasProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] ExecuteWhenLowHealth { <AbilityFlag> constant }
[Entity] health { <Entity> declaration [field] }
[CanUseAbility] ability { <CanUseAbility> declaration [argument] }
[EntityAbility] healthToExecute { <EntityAbility> declaration [field] }
[CanUseAbility] isInRange { <CanUseAbility> declaration [local] }
[CanUseAbility] flags { <CanUseAbility> declaration [local] }
NULL: HasProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] ExecuteWhenInRange { <AbilityFlag> constant }
[Entity] IsInRange { <Entity> function [def] }
[CanUseAbility] ability { <CanUseAbility> declaration [argument] }
[EntityAbility] distanceToExecute { <EntityAbility> declaration [field] }
[CanUseAbility] pos { <CanUseAbility> declaration [local] }
[CanUseAbility] isInRangeY { <CanUseAbility> declaration [local] }
[CanUseAbility] flags { <CanUseAbility> declaration [local] }
NULL: HasProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] ExecuteWhenInRangeY { <AbilityFlag> constant }
[Entity] IsInRangeY { <Entity> function [def] }
[CanUseAbility] ability { <CanUseAbility> declaration [argument] }
[EntityAbility] distanceToExecuteY { <EntityAbility> declaration [field] }
[CanUseAbility] pos { <CanUseAbility> declaration [local] }
[CanUseAbility] moveRegion { <CanUseAbility> declaration [local] }
[CanUseAbility] flags { <CanUseAbility> declaration [local] }
NULL: HasProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] ExecuteWhenOutOfMoveRegion { <AbilityFlag> constant }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] AtEndOfMoveRegion { <EntityProperty> constant }
[CanUseAbility] result { <CanUseAbility> declaration [local] }
[CanUseAbility] Check { <CanUseAbility> function [def] }
[CanUseAbility] ability { <CanUseAbility> declaration [argument] }
[EntityAbility] flags { <EntityAbility> declaration [field] }
NULL: HasProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] OrCombine { <AbilityFlag> constant }
[CanUseAbility] lowHealth { <CanUseAbility> declaration [local] }
[CanUseAbility] isInRange { <CanUseAbility> declaration [local] }
[CanUseAbility] isInRangeY { <CanUseAbility> declaration [local] }
[CanUseAbility] moveRegion { <CanUseAbility> declaration [local] }
[CanUseAbility] result { <CanUseAbility> declaration [local] }
[CanUseAbility] Check { <CanUseAbility> function [def] }
[Check] condition { <Check> declaration [argument] }
[Check] values { <Check> declaration [argument] }
[Check] b { <Check> declaration [local] }
[Check] values { <Check> declaration [argument] }
[Check] b { <Check> declaration [local] }
[Check] condition { <Check> declaration [argument] }
[Check] condition { <Check> declaration [argument] }
[Check] condition { <Check> declaration [argument] }
NULL: IEnumerator
[Entity] UseAbility { <Entity> function [def] }
[Entity] EntityAbility { <Entity> type [def] [product] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[Entity] MoveType { <Entity> type [def] [product] }
[UseAbility] moveType { <UseAbility> declaration [argument] }
[Entity] TargetType { <Entity> type [def] [product] }
[UseAbility] targetType { <UseAbility> declaration [argument] }
[UseAbility] speed { <UseAbility> declaration [argument] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] flags { <EntityAbility> declaration [field] }
NULL: SetProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] CanExecute { <AbilityFlag> constant }
[UseAbility] cooldownTime { <UseAbility> declaration [local] }
[Entity] moveType { <Entity> declaration [field] }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] None { <MoveType> constant }
[UseAbility] timer { <UseAbility> declaration [local] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] vfx { <EntityAbility> declaration [field] }
[EntityVFX] canStop { <EntityVFX> declaration [field] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] flags { <EntityAbility> declaration [field] }
NULL: HasProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] CanExecute { <AbilityFlag> constant }
[Entity] PlayVFX { <Entity> function [def] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] vfx { <EntityAbility> declaration [field] }
[UseAbility] timer { <UseAbility> declaration [local] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] interuptibleTime { <EntityAbility> declaration [field] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] flags { <EntityAbility> declaration [field] }
NULL: HasProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] Interuptible { <AbilityFlag> constant }
[Entity] CanUseAbility { <Entity> function [def] }
[UseAbility] ability { <UseAbility> declaration [argument] }
NULL: END
[UseAbility] timer { <UseAbility> declaration [local] }
NULL: Time
NULL: deltaTime
[Entity] targetType { <Entity> declaration [field] }
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] None { <TargetType> constant }
NULL: WaitForSeconds
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] chargeTime { <EntityAbility> declaration [field] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] interuptibleTime { <EntityAbility> declaration [field] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] type { <EntityAbility> declaration [field] }
[Entity] AbilityType { <Entity> type [def] [product] }
[AbilityType] Move { <AbilityType> constant }
[Entity] moveType { <Entity> declaration [field] }
[UseAbility] moveType { <UseAbility> declaration [argument] }
[Entity] speed { <Entity> declaration [field] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] range { <EntityAbility> declaration [field] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] duration { <EntityAbility> declaration [field] }
[Entity] targetType { <Entity> declaration [field] }
[UseAbility] targetType { <UseAbility> declaration [argument] }
[Entity] damage { <Entity> declaration [field] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] damage { <EntityAbility> declaration [field] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] flags { <EntityAbility> declaration [field] }
NULL: HasProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] AwayFromPlayer { <AbilityFlag> constant }
[Entity] targetDir { <Entity> declaration [field] }
NULL: MathUtils
NULL: Sign
[Entity] targetPos { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
NULL: transform
NULL: position
[NULL] Vector2 { type [def] [product] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] flags { <EntityAbility> declaration [field] }
NULL: HasProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] LockOnPlayerForEternity { <AbilityFlag> constant }
[Entity] testProperties { <Entity> declaration [field] }
NULL: SetProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] StartTrailing { <VFXProperty> constant }
[Entity] StartFalling { <Entity> function [def] }
[Entity] AbilityType { <Entity> type [def] [product] }
[AbilityType] Teleport { <AbilityType> constant }
[{] playerUp { <{> declaration [local] }
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
NULL: up
NULL: y
NULL: Vector3
[{] destination { <{> declaration [local] }
[{] destination { <{> declaration [local] }
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
NULL: position
[{] destination { <{> declaration [local] }
NULL: y
[Entity] spriteExtents { <Entity> declaration [field] }
NULL: y
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
[Entity] spriteExtents { <Entity> declaration [field] }
NULL: y
[{] playerUp { <{> declaration [local] }
[{] distance { <{> declaration [local] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] range { <EntityAbility> declaration [field] }
NULL: Mathf
NULL: Sign
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
NULL: position
NULL: x
NULL: transform
NULL: position
NULL: x
[{] IsPosValid { <{> function [def] }
[{] distance { <{> declaration [local] }
[{] IsPosValid { <{> function [def] }
[{] distance { <{> declaration [local] }
NULL: END
[{] IsPosValid { <{> function [def] }
[IsPosValid] offsetX { <IsPosValid> declaration [argument] }
NULL: Vector3
[IsPosValid] offset { <IsPosValid> declaration [local] }
NULL: Vector3
[IsPosValid] offsetX { <IsPosValid> declaration [argument] }
[IsPosValid] onGround { <IsPosValid> declaration [local] }
NULL: GameUtils
NULL: BoxCast
[{] destination { <{> declaration [local] }
[IsPosValid] offset { <IsPosValid> declaration [local] }
NULL: Vector3
[Entity] spriteExtents { <Entity> declaration [field] }
NULL: y
[{] playerUp { <{> declaration [local] }
[NULL] Vector2 { type [def] [product] }
[Entity] spriteExtents { <Entity> declaration [field] }
NULL: x
NULL: Color
NULL: yellow
[IsPosValid] insideWall { <IsPosValid> declaration [local] }
NULL: GameUtils
NULL: BoxCast
[{] destination { <{> declaration [local] }
[IsPosValid] offset { <IsPosValid> declaration [local] }
NULL: Vector3
[{] playerUp { <{> declaration [local] }
[Entity] sr { <Entity> declaration [field] }
NULL: bounds
NULL: size
NULL: Color
NULL: green
[IsPosValid] onGround { <IsPosValid> declaration [local] }
[IsPosValid] insideWall { <IsPosValid> declaration [local] }
[{] destination { <{> declaration [local] }
NULL: x
[IsPosValid] offsetX { <IsPosValid> declaration [argument] }
[{] playerUp { <{> declaration [local] }
NULL: transform
NULL: up
NULL: y
NULL: transform
NULL: Rotate
NULL: transform
NULL: position
[{] destination { <{> declaration [local] }
[Entity] CalculateMoveRegion { <Entity> function [def] }
[Entity] AbilityType { <Entity> type [def] [product] }
[AbilityType] Explode { <AbilityType> constant }
[Entity] IsInRange { <Entity> function [def] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] range { <EntityAbility> declaration [field] }
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
NULL: position
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
[Entity] Hurt { <Entity> function [def] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] damage { <EntityAbility> declaration [field] }
[Entity] AbilityType { <Entity> type [def] [product] }
[AbilityType] Jump { <AbilityType> constant }
NULL: WaitForSeconds
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] duration { <EntityAbility> declaration [field] }
[UseAbility] cooldownTime { <UseAbility> declaration [local] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] cooldownTime { <EntityAbility> declaration [field] }
NULL: END
[Entity] speed { <Entity> declaration [field] }
[UseAbility] speed { <UseAbility> declaration [argument] }
[Entity] targetType { <Entity> declaration [field] }
[UseAbility] targetType { <UseAbility> declaration [argument] }
[Entity] moveType { <Entity> declaration [field] }
[UseAbility] moveType { <UseAbility> declaration [argument] }
[Entity] currentAbility { <Entity> declaration [field] }
NULL: MathUtils
NULL: LoopIndex
[Entity] currentAbility { <Entity> declaration [field] }
[Entity] abilities { <Entity> declaration [field] }
NULL: Length
NULL: WaitForSeconds
[UseAbility] cooldownTime { <UseAbility> declaration [local] }
[UseAbility] ability { <UseAbility> declaration [argument] }
[EntityAbility] flags { <EntityAbility> declaration [field] }
NULL: SetProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] CanExecute { <AbilityFlag> constant }
[Entity] TargetOffsetType { <Entity> type [def] [product] }
[TargetOffsetType] None { <TargetOffsetType> constant }
[TargetOffsetType] Mouse { <TargetOffsetType> constant }
[TargetOffsetType] Player { <TargetOffsetType> constant }
[Entity] MoveRegionType { <Entity> type [def] [product] }
[MoveRegionType] None { <MoveRegionType> constant }
[MoveRegionType] Ground { <MoveRegionType> constant }
[MoveRegionType] Vertical { <MoveRegionType> constant }
[Entity] AttackTrigger { <Entity> type [def] [product] }
[AttackTrigger] None { <AttackTrigger> constant }
[AttackTrigger] MouseInput { <AttackTrigger> constant }
NULL: Header
[NULL] Property { type [def] [product] }
[NULL] EntityProperty { type [def] [product] }
[Entity] properties { <Entity> declaration [field] }
NULL: SerializedPool
[NULL] Property { type [def] [product] }
[Entity] VFXProperty { <Entity> type [def] [product] }
[Entity] testProperties { <Entity> declaration [field] }
NULL: SerializedPool
[Entity] EntityAbility { <Entity> type [def] [product] }
[Entity] abilities { <Entity> declaration [field] }
[Entity] currentAbility { <Entity> declaration [field] }
[Entity] health { <Entity> declaration [field] }
[Entity] damage { <Entity> declaration [field] }
[Entity] money { <Entity> declaration [field] }
[Entity] ammo { <Entity> declaration [field] }
[Entity] collisionTags { <Entity> declaration [field] }
NULL: MinMax
[NULL] RangedInt { type [def] [product] }
[Entity] valueRange { <Entity> declaration [field] }
NULL: Header
NULL: WeaponStat
[Entity] stat { <Entity> declaration [field] }
[Entity] AttackTrigger { <Entity> type [def] [product] }
[Entity] attackTrigger { <Entity> declaration [field] }
[NULL] RangedFloat { type [def] [product] }
[Entity] attackDuration { <Entity> declaration [field] }
NULL: Header
[Entity] MoveType { <Entity> type [def] [product] }
[Entity] moveType { <Entity> declaration [field] }
[Entity] RotateType { <Entity> type [def] [product] }
[Entity] rotateType { <Entity> declaration [field] }
[Entity] TargetType { <Entity> type [def] [product] }
[Entity] targetType { <Entity> declaration [field] }
NULL: Range
NULL: f
NULL: f
[Entity] speed { <Entity> declaration [field] }
[Entity] dRotate { <Entity> declaration [field] }
[Entity] range { <Entity> declaration [field] }
[Entity] maxFallingSpeed { <Entity> declaration [field] }
[Entity] TargetOffsetType { <Entity> type [def] [product] }
[Entity] offsetType { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[Entity] targetOffset { <Entity> declaration [field] }
NULL: SpringData
[Entity] spring { <Entity> declaration [field] }
NULL: MinMax
[NULL] RangedFloat { type [def] [product] }
[Entity] fallDir { <Entity> declaration [field] }
[Entity] MoveRegionType { <Entity> type [def] [product] }
[Entity] regionType { <Entity> declaration [field] }
NULL: ShowWhen
[Entity] MoveRegionType { <Entity> type [def] [product] }
[MoveRegionType] Vertical { <MoveRegionType> constant }
[Entity] verticalHeight { <Entity> declaration [field] }
NULL: Rect
[Entity] moveRegion { <Entity> declaration [field] }
[Entity] moveTime { <Entity> declaration [field] }
[Entity] moveTimeValue { <Entity> declaration [field] }
[Entity] groundRememberTime { <Entity> declaration [field] }
[Entity] groundRemember { <Entity> declaration [field] }
[Entity] fallRememberTime { <Entity> declaration [field] }
[Entity] fallRemember { <Entity> declaration [field] }
[Entity] jumpPressedRememberTime { <Entity> declaration [field] }
[Entity] jumpPressedRemember { <Entity> declaration [field] }
NULL: AudioType
[Entity] footstepAudio { <Entity> declaration [field] }
[NULL] RangedFloat { type [def] [product] }
[Entity] timeBtwFootsteps { <Entity> declaration [field] }
[Entity] timeBtwFootstepsValue { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[Entity] velocity { <Entity> declaration [field] }
NULL: Rigidbody2D
[Entity] rb { <Entity> declaration [field] }
NULL: Collider2D
[Entity] cd { <Entity> declaration [field] }
[Entity] speedY { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[Entity] targetDir { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[Entity] targetPos { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[Entity] offsetDir { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[Entity] state { <Entity> declaration [field] }
NULL: Header
NULL: Material
[Entity] whiteMat { <Entity> declaration [field] }
NULL: ParticleSystem
[Entity] leftDust { <Entity> declaration [field] }
NULL: ParticleSystem
[Entity] rightDust { <Entity> declaration [field] }
NULL: VFXCollection
[Entity] vfx { <Entity> declaration [field] }
[Entity] EntityVFX { <Entity> type [def] [product] }
[Entity] spawnVFX { <Entity> declaration [field] }
[Entity] deathVFX { <Entity> declaration [field] }
[Entity] hurtVFX { <Entity> declaration [field] }
NULL: TMPro
NULL: TextMeshPro
[Entity] text { <Entity> declaration [field] }
NULL: TrailRenderer
[Entity] trail { <Entity> declaration [field] }
NULL: Animator
[Entity] anim { <Entity> declaration [field] }
NULL: SpriteRenderer
[Entity] sr { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[Entity] spriteExtents { <Entity> declaration [field] }
[Entity] OnObjectInit { <Entity> function [def] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] UsePooling { <EntityProperty> constant }
[Entity] Init { <Entity> function [def] }
[Entity] deathVFX { <Entity> declaration [field] }
[EntityVFX] done { <EntityVFX> declaration [field] }
NULL: gameObject
NULL: SetActive
[Entity] CustomInit { <Entity> function [def] }
[Entity] Init { <Entity> function [def] }
[Entity] OnObjectSpawn { <Entity> function [def] }
[Entity] OnObjectSpawn { <Entity> function [def] }
[Entity] moveTimeValue { <Entity> declaration [field] }
[Entity] moveTime { <Entity> declaration [field] }
NULL: Time
NULL: time
[Entity] CalculateMoveRegion { <Entity> function [def] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] FallingOnSpawn { <EntityProperty> constant }
[Entity] StartFalling { <Entity> function [def] }
[Entity] Start { <Entity> function [def] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] UsePooling { <EntityProperty> constant }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] CustomInit { <EntityProperty> constant }
[Entity] Init { <Entity> function [def] }
[Entity] OnObjectSpawn { <Entity> function [def] }
[Entity] deathVFX { <Entity> declaration [field] }
[EntityVFX] done { <EntityVFX> declaration [field] }
NULL: Destroy
NULL: Initialize
[Entity] Init { <Entity> function [def] }
[Entity] rb { <Entity> declaration [field] }
NULL: GetComponent
NULL: Rigidbody2D
[Entity] cd { <Entity> declaration [field] }
NULL: GetComponent
NULL: Collider2D
[Entity] text { <Entity> declaration [field] }
NULL: GetComponent
NULL: TMPro
NULL: TextMeshPro
[Entity] trail { <Entity> declaration [field] }
NULL: GetComponent
NULL: TrailRenderer
[Entity] anim { <Entity> declaration [field] }
NULL: GetComponent
NULL: Animator
[Entity] sr { <Entity> declaration [field] }
NULL: GetComponent
NULL: SpriteRenderer
[Entity] rb { <Entity> declaration [field] }
[Entity] maxFallingSpeed { <Entity> declaration [field] }
[{] drag { <{> declaration [local] }
NULL: MathUtils
NULL: GetDragFromAcceleration
NULL: Mathf
NULL: Abs
NULL: Physics2D
NULL: gravity
NULL: y
[Entity] rb { <Entity> declaration [field] }
NULL: gravityScale
[Entity] maxFallingSpeed { <Entity> declaration [field] }
NULL: Debug
NULL: Assert
[{] drag { <{> declaration [local] }
[{] drag { <{> declaration [local] }
[Entity] rb { <Entity> declaration [field] }
NULL: drag
[{] drag { <{> declaration [local] }
[Entity] whiteMat { <Entity> declaration [field] }
[Entity] whiteMat { <Entity> declaration [field] }
NULL: Instantiate
[Entity] whiteMat { <Entity> declaration [field] }
[Entity] sr { <Entity> declaration [field] }
[Entity] spriteExtents { <Entity> declaration [field] }
[Entity] sr { <Entity> declaration [field] }
NULL: bounds
NULL: extents
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] SpawnCellWhenDie { <EntityProperty> constant }
[Entity] deathVFX { <Entity> declaration [field] }
[EntityVFX] done { <EntityVFX> declaration [field] }
[] dropValue { <> declaration [local] }
[Entity] valueRange { <Entity> declaration [field] }
[RangedInt] randomValue { <RangedInt> declaration [property] }
[] i { <> declaration [local] }
[] i { <> declaration [local] }
[] dropValue { <> declaration [local] }
[] i { <> declaration [local] }
NULL: ObjectPooler
NULL: Spawn
NULL: PoolType
NULL: Cell
NULL: transform
NULL: position
[Entity] MoveType { <Entity> type [def] [product] }
[Init] move { <Init> declaration [local] }
[Entity] moveType { <Entity> declaration [field] }
[Entity] RotateType { <Entity> type [def] [product] }
[Init] rotate { <Init> declaration [local] }
[Entity] rotateType { <Entity> declaration [field] }
[Entity] hurtVFX { <Entity> declaration [field] }
[EntityVFX] done { <EntityVFX> declaration [field] }
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] CanBeHurt { <EntityProperty> constant }
[Entity] moveType { <Entity> declaration [field] }
[Init] move { <Init> declaration [local] }
[Entity] rotateType { <Entity> declaration [field] }
[Init] rotate { <Init> declaration [local] }
[Entity] ammo { <Entity> declaration [field] }
[Entity] stat { <Entity> declaration [field] }
NULL: ammo
[Entity] spring { <Entity> declaration [field] }
[Entity] spring { <Entity> declaration [field] }
NULL: f
[Entity] spring { <Entity> declaration [field] }
NULL: Init
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
NULL: position
NULL: y
[Entity] state { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[EntityState] OnSpawn { <EntityState> constant }
[Entity] InitCamera { <Entity> function [def] }
[InitCamera] automatic { <InitCamera> declaration [argument] }
[InitCamera] useSmoothDamp { <InitCamera> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[InitCamera] value { <InitCamera> declaration [argument] }
[InitCamera] waitTime { <InitCamera> declaration [argument] }
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] StartAtMinMoveRegion { <EntityProperty> constant }
[InitCamera] automatic { <InitCamera> declaration [argument] }
[Entity] offsetType { <Entity> declaration [field] }
[InitCamera] automatic { <InitCamera> declaration [argument] }
[Entity] TargetOffsetType { <Entity> type [def] [product] }
[TargetOffsetType] None { <TargetOffsetType> constant }
[Entity] TargetOffsetType { <Entity> type [def] [product] }
[TargetOffsetType] Mouse { <TargetOffsetType> constant }
[Entity] targetType { <Entity> declaration [field] }
[InitCamera] automatic { <InitCamera> declaration [argument] }
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] MoveRegion { <TargetType> constant }
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] Player { <TargetType> constant }
[Entity] speed { <Entity> declaration [field] }
[InitCamera] value { <InitCamera> declaration [argument] }
NULL: magnitude
[Entity] moveType { <Entity> declaration [field] }
[InitCamera] useSmoothDamp { <InitCamera> declaration [argument] }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] SmoothDamp { <MoveType> constant }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] Fly { <MoveType> constant }
[Entity] speed { <Entity> declaration [field] }
[InitCamera] value { <InitCamera> declaration [argument] }
NULL: x
[Entity] speedY { <Entity> declaration [field] }
[InitCamera] value { <InitCamera> declaration [argument] }
NULL: y
[Entity] abilities { <Entity> declaration [field] }
NULL: flags
[NULL] Property { type [def] [product] }
[Entity] AbilityFlag { <Entity> type [def] [product] }
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] ExecuteWhenOutOfMoveRegion { <AbilityFlag> constant }
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] CanExecute { <AbilityFlag> constant }
[Entity] abilities { <Entity> declaration [field] }
NULL: chargeTime
[InitCamera] waitTime { <InitCamera> declaration [argument] }
NULL: GameInput
NULL: BindEvent
NULL: GameEventType
NULL: NextRoom
[] room { <> declaration [argument] }
[InitCamera] ToNextRoom { <InitCamera> function [def] }
[NULL] GameManager { type [def] [product] }
[GameManager] GetBoundsFromRoom { <GameManager> function [def] }
[] room { <> declaration [argument] }
NULL: ToRect
[InitCamera] ToNextRoom { <InitCamera> function [def] }
NULL: Rect
[ToNextRoom] roomRect { <ToNextRoom> declaration [argument] }
[Entity] moveRegion { <Entity> declaration [field] }
[ToNextRoom] roomRect { <ToNextRoom> declaration [argument] }
[Entity] moveRegion { <Entity> declaration [field] }
NULL: min
[NULL] GameManager { type [def] [product] }
[GameManager] mainCam { <GameManager> declaration [field] }
NULL: HalfSize
[Entity] moveRegion { <Entity> declaration [field] }
NULL: max
[NULL] GameManager { type [def] [product] }
[GameManager] mainCam { <GameManager> declaration [field] }
NULL: HalfSize
NULL: Debug
NULL: Assert
[Entity] moveRegion { <Entity> declaration [field] }
NULL: xMin
[Entity] moveRegion { <Entity> declaration [field] }
NULL: xMax
[Entity] moveRegion { <Entity> declaration [field] }
NULL: yMin
[Entity] moveRegion { <Entity> declaration [field] }
NULL: yMax
[Entity] InitBullet { <Entity> function [def] }
[InitBullet] damage { <InitBullet> declaration [argument] }
[InitBullet] isCritical { <InitBullet> declaration [argument] }
[InitBullet] hitPlayer { <InitBullet> declaration [argument] }
[Entity] damage { <Entity> declaration [field] }
[InitBullet] damage { <InitBullet> declaration [argument] }
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] IsCritical { <EntityProperty> constant }
[InitBullet] isCritical { <InitBullet> declaration [argument] }
[Entity] collisionTags { <Entity> declaration [field] }
[InitBullet] hitPlayer { <InitBullet> declaration [argument] }
[Entity] InitDamagePopup { <Entity> function [def] }
[InitDamagePopup] damage { <InitDamagePopup> declaration [argument] }
[InitDamagePopup] isCritical { <InitDamagePopup> declaration [argument] }
[Entity] targetDir { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
NULL: one
[Entity] text { <Entity> declaration [field] }
NULL: text
[InitDamagePopup] damage { <InitDamagePopup> declaration [argument] }
NULL: ToString
[Entity] spawnVFX { <Entity> declaration [field] }
[Entity] EntityVFX { <Entity> type [def] [product] }
[Entity] properties { <Entity> declaration [field] }
[NULL] Property { type [def] [product] }
[Entity] VFXProperty { <Entity> type [def] [product] }
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] ScaleOverTime { <VFXProperty> constant }
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] FadeTextWhenDone { <VFXProperty> constant }
NULL: scaleTime
[Entity] moveTime { <Entity> declaration [field] }
NULL: scaleOffset
[NULL] Vector2 { type [def] [product] }
NULL: one
NULL: fadeTime
NULL: f
NULL: f
NULL: fontSize
[InitDamagePopup] isCritical { <InitDamagePopup> declaration [argument] }
NULL: f
NULL: textColor
[InitDamagePopup] isCritical { <InitDamagePopup> declaration [argument] }
NULL: Color
NULL: red
NULL: Color
NULL: white
[Entity] PlayVFX { <Entity> function [def] }
[Entity] spawnVFX { <Entity> declaration [field] }
NULL: EasyButtons
NULL: Button
[Entity] Pickup { <Entity> function [def] }
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
[Entity] spring { <Entity> declaration [field] }
NULL: Init
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
NULL: position
NULL: y
[Entity] offsetType { <Entity> declaration [field] }
[Entity] TargetOffsetType { <Entity> type [def] [product] }
[TargetOffsetType] Player { <TargetOffsetType> constant }
[Entity] moveType { <Entity> declaration [field] }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] Spring { <MoveType> constant }
[Entity] targetType { <Entity> declaration [field] }
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] Player { <TargetType> constant }
[Entity] rotateType { <Entity> declaration [field] }
[Entity] RotateType { <Entity> type [def] [product] }
[RotateType] Weapon { <RotateType> constant }
[Entity] attackTrigger { <Entity> declaration [field] }
[Entity] AttackTrigger { <Entity> type [def] [product] }
[AttackTrigger] MouseInput { <AttackTrigger> constant }
[Entity] Shoot { <Entity> function [def] }
[Shoot] isCritical { <Shoot> declaration [argument] }
[NULL] Entity { type [def] [product] }
[Shoot] bullet { <Shoot> declaration [local] }
NULL: ObjectPooler
NULL: Spawn
[NULL] Entity { type [def] [product] }
NULL: PoolType
NULL: Bullet_Normal
NULL: transform
NULL: position
NULL: transform
NULL: eulerAngles
[Shoot] bullet { <Shoot> declaration [local] }
[Entity] InitBullet { <Entity> function [def] }
[Shoot] isCritical { <Shoot> declaration [argument] }
[Entity] stat { <Entity> declaration [field] }
NULL: damage
[Entity] stat { <Entity> declaration [field] }
NULL: critDamage
[Shoot] isCritical { <Shoot> declaration [argument] }
[Entity] Update { <Entity> function [def] }
NULL: Time
NULL: deltaTime
[Update] wasGrounded { <Update> declaration [local] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] IsGrounded { <EntityProperty> constant }
[Update] isGrounded { <Update> declaration [local] }
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] IsGrounded { <EntityProperty> constant }
NULL: GameUtils
NULL: GroundCheck
NULL: transform
NULL: position
[Entity] spriteExtents { <Entity> declaration [field] }
NULL: transform
NULL: up
NULL: y
NULL: Color
NULL: red
[Entity] abilities { <Entity> declaration [field] }
NULL: Length
[Entity] abilities { <Entity> declaration [field] }
[Entity] currentAbility { <Entity> declaration [field] }
NULL: flags
NULL: HasProperty
[Entity] AbilityFlag { <Entity> type [def] [product] }
[AbilityFlag] CanExecute { <AbilityFlag> constant }
[Entity] CanUseAbility { <Entity> function [def] }
[Entity] abilities { <Entity> declaration [field] }
[Entity] currentAbility { <Entity> declaration [field] }
NULL: StartCoroutine
[Entity] UseAbility { <Entity> function [def] }
[Entity] abilities { <Entity> declaration [field] }
[Entity] currentAbility { <Entity> declaration [field] }
[Entity] moveType { <Entity> declaration [field] }
[Entity] targetType { <Entity> declaration [field] }
[Entity] speed { <Entity> declaration [field] }
[Entity] groundRemember { <Entity> declaration [field] }
NULL: Time
NULL: deltaTime
[Update] isGrounded { <Update> declaration [local] }
[Entity] groundRemember { <Entity> declaration [field] }
[Entity] groundRememberTime { <Entity> declaration [field] }
[Entity] fallRemember { <Entity> declaration [field] }
NULL: Time
NULL: deltaTime
[Update] isGrounded { <Update> declaration [local] }
[Entity] fallRemember { <Entity> declaration [field] }
[Entity] fallRememberTime { <Entity> declaration [field] }
[Entity] jumpPressedRemember { <Entity> declaration [field] }
NULL: Time
NULL: deltaTime
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] CanJump { <EntityProperty> constant }
NULL: GameInput
NULL: GetInput
NULL: InputType
NULL: Jump
[Entity] jumpPressedRemember { <Entity> declaration [field] }
[Entity] jumpPressedRememberTime { <Entity> declaration [field] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] FallingOnSpawn { <EntityProperty> constant }
[Update] isGrounded { <Update> declaration [local] }
[{] canShoot { <{> declaration [local] }
[{] canReload { <{> declaration [local] }
[Entity] attackTrigger { <Entity> declaration [field] }
[Entity] AttackTrigger { <Entity> type [def] [product] }
[AttackTrigger] MouseInput { <AttackTrigger> constant }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] IsReloading { <EntityProperty> constant }
[{] canShoot { <{> declaration [local] }
[Entity] ammo { <Entity> declaration [field] }
NULL: GameInput
NULL: GetInput
NULL: InputType
NULL: Shoot
[{] canReload { <{> declaration [local] }
[Entity] ammo { <Entity> declaration [field] }
[Entity] stat { <Entity> declaration [field] }
NULL: ammo
NULL: GameInput
NULL: GetInput
NULL: InputType
NULL: Reload
[{] canShoot { <{> declaration [local] }
NULL: Time
NULL: time
[Entity] attackDuration { <Entity> declaration [field] }
[RangedFloat] max { <RangedFloat> declaration [field] }
[Entity] ammo { <Entity> declaration [field] }
[Entity] attackDuration { <Entity> declaration [field] }
[RangedFloat] max { <RangedFloat> declaration [field] }
NULL: Time
NULL: time
[Entity] stat { <Entity> declaration [field] }
NULL: timeBtwShots
[Entity] state { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[EntityState] StartAttack { <EntityState> constant }
[{] isCritical { <{> declaration [local] }
NULL: Random
NULL: value
[Entity] stat { <Entity> declaration [field] }
NULL: critChance
[{] rot { <{> declaration [local] }
[Entity] attackDuration { <Entity> declaration [field] }
[RangedFloat] range { <RangedFloat> declaration [property] }
NULL: Mathf
NULL: PerlinNoise
[Entity] attackDuration { <Entity> declaration [field] }
[RangedFloat] range { <RangedFloat> declaration [property] }
NULL: f
NULL: f
NULL: f
[Entity] Shoot { <Entity> function [def] }
[{] isCritical { <{> declaration [local] }
[Entity] ammo { <Entity> declaration [field] }
[{] canShoot { <{> declaration [local] }
[{] canReload { <{> declaration [local] }
NULL: StartCoroutine
[{] Reloading { <{> function [def] }
[Entity] stat { <Entity> declaration [field] }
[NULL] GameManager { type [def] [product] }
[GameManager] gameUI { <GameManager> declaration [field] }
NULL: UpdateReload
[] enable { <> declaration [argument] }
[NULL] GameManager { type [def] [product] }
[GameManager] gameUI { <GameManager> declaration [field] }
NULL: EnableReload
[] enable { <> declaration [argument] }
[Entity] stat { <Entity> declaration [field] }
NULL: standardReload
NULL: GameInput
NULL: EnableInput
NULL: InputType
NULL: Interact
[] enable { <> declaration [argument] }
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] IsReloading { <EntityProperty> constant }
[] enable { <> declaration [argument] }
[Entity] ammo { <Entity> declaration [field] }
[] enable { <> declaration [argument] }
[Entity] stat { <Entity> declaration [field] }
NULL: ammo
NULL: IEnumerator
[{] Reloading { <{> function [def] }
NULL: WeaponStat
[Reloading] stat { <Reloading> declaration [argument] }
NULL: System
NULL: Func
[Reloading] updateUI { <Reloading> declaration [argument] }
NULL: System
NULL: Action
[Reloading] enable { <Reloading> declaration [argument] }
[Reloading] enable { <Reloading> declaration [argument] }
[Reloading] maxTime { <Reloading> declaration [local] }
[Reloading] stat { <Reloading> declaration [argument] }
NULL: standardReload
[Reloading] t { <Reloading> declaration [local] }
[Reloading] hasReloaded { <Reloading> declaration [local] }
[Reloading] t { <Reloading> declaration [local] }
[Reloading] maxTime { <Reloading> declaration [local] }
[Reloading] t { <Reloading> declaration [local] }
NULL: Time
NULL: deltaTime
[Reloading] hasReloaded { <Reloading> declaration [local] }
[{] isPerfect { <{> declaration [local] }
[Reloading] updateUI { <Reloading> declaration [argument] }
[Reloading] t { <Reloading> declaration [local] }
[Reloading] hasReloaded { <Reloading> declaration [local] }
NULL: GameInput
NULL: GetInput
NULL: InputType
NULL: Reload
[Reloading] hasReloaded { <Reloading> declaration [local] }
[Reloading] maxTime { <Reloading> declaration [local] }
[{] isPerfect { <{> declaration [local] }
[Reloading] stat { <Reloading> declaration [argument] }
NULL: perfectReload
[Reloading] stat { <Reloading> declaration [argument] }
NULL: failedReload
[Reloading] enable { <Reloading> declaration [argument] }
[{] canShoot { <{> declaration [local] }
[Entity] attackDuration { <Entity> declaration [field] }
[RangedFloat] min { <RangedFloat> declaration [field] }
[Entity] attackDuration { <Entity> declaration [field] }
[RangedFloat] max { <RangedFloat> declaration [field] }
NULL: Time
NULL: time
[Entity] moveTimeValue { <Entity> declaration [field] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] DieAfterMoveTime { <EntityProperty> constant }
[Entity] Die { <Entity> function [def] }
[Entity] RotateEntity { <Entity> function [def] }
NULL: transform
[Entity] rotateType { <Entity> declaration [field] }
[Entity] dRotate { <Entity> declaration [field] }
[Entity] velocity { <Entity> declaration [field] }
NULL: x
[NULL] Vector2 { type [def] [product] }
[Update] prevVelocity { <Update> declaration [local] }
[Entity] velocity { <Entity> declaration [field] }
[Entity] MoveEntity { <Entity> function [def] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] ClampToMoveRegion { <EntityProperty> constant }
NULL: transform
NULL: position
NULL: MathUtils
NULL: Clamp
NULL: transform
NULL: position
[Entity] moveRegion { <Entity> declaration [field] }
NULL: min
[Entity] moveRegion { <Entity> declaration [field] }
NULL: max
NULL: transform
NULL: position
NULL: z
[Update] startJumping { <Update> declaration [local] }
[Entity] jumpPressedRemember { <Entity> declaration [field] }
[Entity] groundRemember { <Entity> declaration [field] }
[Entity] EntityVFX { <Entity> type [def] [product] }
[{] playerVFX { <{> declaration [local] }
[Entity] EntityVFX { <Entity> type [def] [product] }
NULL: shakeMode
NULL: ShakeMode
NULL: PlayerJump
NULL: waitTime
NULL: particles
NULL: ParticleSystem
[Entity] velocity { <Entity> declaration [field] }
NULL: x
[Entity] leftDust { <Entity> declaration [field] }
[Entity] velocity { <Entity> declaration [field] }
NULL: x
[Entity] rightDust { <Entity> declaration [field] }
[Update] startJumping { <Update> declaration [local] }
[Entity] state { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[EntityState] Jumping { <EntityState> constant }
[Entity] jumpPressedRemember { <Entity> declaration [field] }
[Entity] groundRemember { <Entity> declaration [field] }
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] IsGrounded { <EntityProperty> constant }
[Entity] rb { <Entity> declaration [field] }
NULL: gravityScale
[{] playerVFX { <{> declaration [local] }
[EntityVFX] audio { <EntityVFX> declaration [field] }
NULL: AudioType
NULL: Player_Jump
[{] playerVFX { <{> declaration [local] }
[EntityVFX] scaleOffset { <EntityVFX> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[{] playerVFX { <{> declaration [local] }
[EntityVFX] rotateTime { <EntityVFX> declaration [field] }
[{] playerVFX { <{> declaration [local] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: SetProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] FlipX { <VFXProperty> constant }
[Update] wasGrounded { <Update> declaration [local] }
[Update] isGrounded { <Update> declaration [local] }
[Entity] state { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[EntityState] Landing { <EntityState> constant }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] FallingOnSpawn { <EntityProperty> constant }
[Entity] StartFalling { <Entity> function [def] }
[{] playerVFX { <{> declaration [local] }
[EntityVFX] audio { <EntityVFX> declaration [field] }
NULL: AudioType
NULL: Player_Land
[{] playerVFX { <{> declaration [local] }
[EntityVFX] scaleOffset { <EntityVFX> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[Entity] velocity { <Entity> declaration [field] }
NULL: x
NULL: CapsuleCollider2D
[{] capsule { <{> declaration [local] }
[Entity] cd { <Entity> declaration [field] }
NULL: CapsuleCollider2D
[{] capsule { <{> declaration [local] }
[{] capsule { <{> declaration [local] }
NULL: direction
NULL: CapsuleDirection2D
NULL: Horizontal
[{] playerVFX { <{> declaration [local] }
[EntityVFX] done { <EntityVFX> declaration [field] }
[{] capsule { <{> declaration [local] }
NULL: direction
NULL: CapsuleDirection2D
NULL: Vertical
[Update] wasGrounded { <Update> declaration [local] }
[Update] isGrounded { <Update> declaration [local] }
[Entity] state { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[EntityState] Falling { <EntityState> constant }
[{] playerVFX { <{> declaration [local] }
[Entity] EntityVFX { <Entity> type [def] [product] }
[Entity] properties { <Entity> declaration [field] }
[NULL] Property { type [def] [product] }
[Entity] VFXProperty { <Entity> type [def] [product] }
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] StopAnimation { <VFXProperty> constant }
NULL: nextAnimation
[{] playerVFX { <{> declaration [local] }
[Update] isGrounded { <Update> declaration [local] }
[NULL] Vector2 { type [def] [product] }
[{] deltaVelocity { <{> declaration [local] }
[Entity] velocity { <Entity> declaration [field] }
[Update] prevVelocity { <Update> declaration [local] }
[Entity] velocity { <Entity> declaration [field] }
NULL: x
NULL: Time
NULL: time
[Entity] timeBtwFootstepsValue { <Entity> declaration [field] }
[Entity] timeBtwFootstepsValue { <Entity> declaration [field] }
NULL: Time
NULL: time
[Entity] timeBtwFootsteps { <Entity> declaration [field] }
[RangedFloat] randomValue { <RangedFloat> declaration [property] }
[{] playerVFX { <{> declaration [local] }
[Entity] EntityVFX { <Entity> type [def] [product] }
NULL: audio
[Entity] footstepAudio { <Entity> declaration [field] }
[{] deltaVelocity { <{> declaration [local] }
NULL: x
[{] playerVFX { <{> declaration [local] }
[{] playerVFX { <{> declaration [local] }
[Entity] EntityVFX { <Entity> type [def] [product] }
[{] playerVFX { <{> declaration [local] }
[EntityVFX] particles { <EntityVFX> declaration [field] }
NULL: ParticleSystem
[{] deltaVelocity { <{> declaration [local] }
NULL: x
[Entity] leftDust { <Entity> declaration [field] }
[Entity] rightDust { <Entity> declaration [field] }
[Update] prevVelocity { <Update> declaration [local] }
NULL: x
[Entity] state { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[EntityState] StartMoving { <EntityState> constant }
[{] playerVFX { <{> declaration [local] }
[EntityVFX] nextAnimation { <EntityVFX> declaration [field] }
[Entity] velocity { <Entity> declaration [field] }
NULL: x
[Entity] state { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[EntityState] StopMoving { <EntityState> constant }
[{] playerVFX { <{> declaration [local] }
[EntityVFX] nextAnimation { <EntityVFX> declaration [field] }
[NULL] SCRIPTABLE_VFX { macro }
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
[Entity] PlayVFX { <Entity> function [def] }
[{] playerVFX { <{> declaration [local] }
[Entity] vfx { <Entity> declaration [field] }
[{] effect { <{> declaration [local] }
[Entity] vfx { <Entity> declaration [field] }
NULL: items
[Entity] state { <Entity> declaration [field] }
NULL: StartCoroutine
[Entity] PlayVFX { <Entity> function [def] }
[{] effect { <{> declaration [local] }
[Entity] state { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[EntityState] None { <EntityState> constant }
NULL: IEnumerator
[Entity] PlayVFX { <Entity> function [def] }
NULL: VFX
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: Debug
NULL: Log
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: name
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: timeline
NULL: min
NULL: WaitForSeconds
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: timeline
NULL: min
NULL: System
NULL: Action
[PlayVFX] after { <PlayVFX> declaration [local] }
NULL: IEnumerator
[PlayVFX] enumerators { <PlayVFX> declaration [local] }
NULL: IEnumerator
[PlayVFX] enumeratorCount { <PlayVFX> declaration [local] }
[{] duration { <{> declaration [local] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: OverTime
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: timeline
NULL: range
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: OffsetPosition
[{] Offset { <{> function [def] }
NULL: transform
NULL: position
[] p { <> declaration [argument] }
NULL: transform
NULL: position
[] p { <> declaration [argument] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: OffsetScale
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: type
NULL: VFXType
NULL: Trail
[{] Offset { <{> function [def] }
NULL: transform
NULL: localScale
[] s { <> declaration [argument] }
NULL: transform
NULL: localScale
[] s { <> declaration [argument] }
[{] Offset { <{> function [def] }
NULL: System
NULL: Func
NULL: Vector3
[Offset] getter { <Offset> declaration [argument] }
NULL: System
NULL: Action
NULL: Vector3
[Offset] setter { <Offset> declaration [argument] }
NULL: StartCoroutine
[Offset] ChangeOverTime { <Offset> function [def] }
[] p { <> declaration [argument] }
[Offset] setter { <Offset> declaration [argument] }
[] p { <> declaration [argument] }
[Offset] getter { <Offset> declaration [argument] }
[Offset] getter { <Offset> declaration [argument] }
NULL: Vector3
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: offset
[{] duration { <{> declaration [local] }
[PlayVFX] after { <PlayVFX> declaration [local] }
NULL: StartCoroutine
[Offset] ChangeOverTime { <Offset> function [def] }
[] p { <> declaration [argument] }
[Offset] setter { <Offset> declaration [argument] }
[] p { <> declaration [argument] }
[Offset] getter { <Offset> declaration [argument] }
[Offset] getter { <Offset> declaration [argument] }
NULL: Vector3
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: offset
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: stayTime
NULL: IEnumerator
[Offset] ChangeOverTime { <Offset> function [def] }
NULL: System
NULL: Action
NULL: Vector3
[ChangeOverTime] setValue { <ChangeOverTime> declaration [argument] }
NULL: Vector3
[ChangeOverTime] startValue { <ChangeOverTime> declaration [argument] }
NULL: Vector3
[ChangeOverTime] endValue { <ChangeOverTime> declaration [argument] }
[ChangeOverTime] decreaseTime { <ChangeOverTime> declaration [argument] }
[ChangeOverTime] decreaseTime { <ChangeOverTime> declaration [argument] }
[{] t { <{> declaration [local] }
[{] t { <{> declaration [local] }
[ChangeOverTime] setValue { <ChangeOverTime> declaration [argument] }
NULL: Vector3
NULL: Lerp
[ChangeOverTime] startValue { <ChangeOverTime> declaration [argument] }
[ChangeOverTime] endValue { <ChangeOverTime> declaration [argument] }
[{] t { <{> declaration [local] }
[{] t { <{> declaration [local] }
NULL: Time
NULL: deltaTime
[ChangeOverTime] decreaseTime { <ChangeOverTime> declaration [argument] }
[ChangeOverTime] setValue { <ChangeOverTime> declaration [argument] }
[ChangeOverTime] endValue { <ChangeOverTime> declaration [argument] }
[PlayVFX] after { <PlayVFX> declaration [local] }
NULL: Vector3
[] rotation { <> declaration [local] }
NULL: Vector3
NULL: zero
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: FlipX
[] rotation { <> declaration [local] }
NULL: x
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: FlipY
[] rotation { <> declaration [local] }
NULL: y
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: FlipZ
[] rotation { <> declaration [local] }
NULL: z
NULL: transform
NULL: Rotate
[] rotation { <> declaration [local] }
[Entity] anim { <Entity> declaration [field] }
NULL: IsNullOrEmpty
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: animation
[Entity] anim { <Entity> declaration [field] }
NULL: Play
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: animation
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: StopAnimation
[Entity] anim { <Entity> declaration [field] }
NULL: speed
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: ResumeAnimation
[PlayVFX] after { <PlayVFX> declaration [local] }
[Entity] anim { <Entity> declaration [field] }
NULL: speed
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: StopTime
NULL: StartCoroutine
NULL: GameUtils
NULL: StopTime
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: timeline
NULL: range
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: ToggleCurrent
NULL: gameObject
NULL: SetActive
NULL: gameObject
NULL: activeSelf
NULL: ParticleEffect
NULL: instance
NULL: SpawnParticle
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: particleType
NULL: transform
NULL: position
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: size
NULL: AudioManager
NULL: PlayAudio
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: audio
NULL: CameraSystem
NULL: instance
NULL: Shake
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: shakeMode
NULL: CameraSystem
NULL: instance
NULL: Shock
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: speed
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: size
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: pools
NULL: PoolType
[{] pool { <{> declaration [local] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: pools
NULL: ObjectPooler
NULL: Spawn
[{] pool { <{> declaration [local] }
NULL: transform
NULL: position
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: type
NULL: VFXType
NULL: Camera
NULL: StartCoroutine
NULL: CameraSystem
NULL: instance
NULL: Flash
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: timeline
NULL: range
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: color
NULL: a
NULL: VFXType
NULL: Flash
NULL: StartCoroutine
[{] Flashing { <{> function [def] }
[Entity] sr { <Entity> declaration [field] }
[Entity] whiteMat { <Entity> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: color
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: timeline
NULL: range
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: stayTime
NULL: IEnumerator
[{] Flashing { <{> function [def] }
NULL: SpriteRenderer
[Flashing] sr { <Flashing> declaration [argument] }
NULL: Material
[Flashing] whiteMat { <Flashing> declaration [argument] }
NULL: Color
[Flashing] color { <Flashing> declaration [argument] }
[Flashing] duration { <Flashing> declaration [argument] }
[Flashing] flashTime { <Flashing> declaration [argument] }
[Flashing] whiteMat { <Flashing> declaration [argument] }
[Flashing] whiteMat { <Flashing> declaration [argument] }
NULL: color
[Flashing] color { <Flashing> declaration [argument] }
NULL: Debug
NULL: Log
[Flashing] duration { <Flashing> declaration [argument] }
[{] currentTime { <{> declaration [local] }
NULL: Time
NULL: time
NULL: Material
[{] defMat { <{> declaration [local] }
[Flashing] sr { <Flashing> declaration [argument] }
NULL: material
[Flashing] sr { <Flashing> declaration [argument] }
NULL: material
[Flashing] whiteMat { <Flashing> declaration [argument] }
NULL: WaitForSeconds
[Flashing] flashTime { <Flashing> declaration [argument] }
[Flashing] sr { <Flashing> declaration [argument] }
NULL: material
[{] defMat { <{> declaration [local] }
NULL: WaitForSeconds
[Flashing] flashTime { <Flashing> declaration [argument] }
[Flashing] duration { <Flashing> declaration [argument] }
NULL: Time
NULL: time
[{] currentTime { <{> declaration [local] }
[Flashing] whiteMat { <Flashing> declaration [argument] }
NULL: color
NULL: Color
NULL: white
NULL: Debug
NULL: Log
NULL: VFXType
NULL: Fade
NULL: StartCoroutine
[PlayVFX] DecreaseOverTime { <PlayVFX> function [def] }
[] alpha { <> declaration [argument] }
[Entity] sr { <Entity> declaration [field] }
NULL: color
NULL: Color
[] alpha { <> declaration [argument] }
[Entity] sr { <Entity> declaration [field] }
NULL: color
NULL: a
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: color
NULL: a
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: timeline
NULL: range
NULL: VFXType
NULL: Trail
NULL: StartCoroutine
[{] EnableTrail { <{> function [def] }
[Entity] trail { <Entity> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: timeline
NULL: range
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: stayTime
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: OffsetScale
[PlayVFX] after { <PlayVFX> declaration [local] }
NULL: StartCoroutine
[PlayVFX] DecreaseOverTime { <PlayVFX> function [def] }
[] width { <> declaration [argument] }
[Entity] trail { <Entity> declaration [field] }
NULL: widthMultiplier
[] width { <> declaration [argument] }
[Entity] trail { <Entity> declaration [field] }
NULL: widthMultiplier
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: stayTime
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: FadeOut
NULL: IEnumerator
[{] EnableTrail { <{> function [def] }
NULL: TrailRenderer
[EnableTrail] trail { <EnableTrail> declaration [argument] }
[EnableTrail] emitTime { <EnableTrail> declaration [argument] }
[EnableTrail] stayTime { <EnableTrail> declaration [argument] }
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: enabled
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: emitting
NULL: WaitForSeconds
[EnableTrail] emitTime { <EnableTrail> declaration [argument] }
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: emitting
NULL: WaitForSeconds
[EnableTrail] stayTime { <EnableTrail> declaration [argument] }
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: Clear
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: emitting
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: enabled
NULL: VFXType
NULL: Text
NULL: TMPro
NULL: TextMeshPro
[{] text { <{> declaration [local] }
NULL: GetComponent
NULL: TMPro
NULL: TextMeshPro
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: color
NULL: Color
NULL: clear
[{] text { <{> declaration [local] }
NULL: color
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: color
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: size
[{] text { <{> declaration [local] }
NULL: fontSize
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: size
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: flags
NULL: HasProperty
NULL: VFXFlag
NULL: FadeOut
[PlayVFX] after { <PlayVFX> declaration [local] }
NULL: StartCoroutine
[PlayVFX] DecreaseOverTime { <PlayVFX> function [def] }
[] alpha { <> declaration [argument] }
[{] text { <{> declaration [local] }
NULL: alpha
[] alpha { <> declaration [argument] }
[{] text { <{> declaration [local] }
NULL: alpha
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: stayTime
NULL: WaitForSeconds
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: timeline
NULL: range
[PlayVFX] after { <PlayVFX> declaration [local] }
NULL: IEnumerator
[PlayVFX] DecreaseOverTime { <PlayVFX> function [def] }
NULL: System
NULL: Action
[DecreaseOverTime] setValue { <DecreaseOverTime> declaration [argument] }
[DecreaseOverTime] startValue { <DecreaseOverTime> declaration [argument] }
[DecreaseOverTime] decreaseTime { <DecreaseOverTime> declaration [argument] }
[DecreaseOverTime] decreaseTime { <DecreaseOverTime> declaration [argument] }
[{] t { <{> declaration [local] }
[{] t { <{> declaration [local] }
[DecreaseOverTime] setValue { <DecreaseOverTime> declaration [argument] }
NULL: Mathf
NULL: Lerp
[DecreaseOverTime] startValue { <DecreaseOverTime> declaration [argument] }
[{] t { <{> declaration [local] }
[{] t { <{> declaration [local] }
NULL: Time
NULL: deltaTime
[DecreaseOverTime] decreaseTime { <DecreaseOverTime> declaration [argument] }
NULL: WaitForEndOfFrame
[DecreaseOverTime] setValue { <DecreaseOverTime> declaration [argument] }
[DecreaseOverTime] startValue { <DecreaseOverTime> declaration [argument] }
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] None { <TargetType> constant }
[TargetType] Input { <TargetType> constant }
[TargetType] Player { <TargetType> constant }
[TargetType] Random { <TargetType> constant }
[TargetType] MoveDir { <TargetType> constant }
[TargetType] MoveRegion { <TargetType> constant }
[TargetType] Target { <TargetType> constant }
[TargetType] Count { <TargetType> constant }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] None { <MoveType> constant }
[MoveType] Run { <MoveType> constant }
[MoveType] Fly { <MoveType> constant }
[MoveType] SmoothDamp { <MoveType> constant }
[MoveType] Custom { <MoveType> constant }
[MoveType] Spring { <MoveType> constant }
[MoveType] Count { <MoveType> constant }
[Entity] MoveEntity { <Entity> function [def] }
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] AtEndOfMoveRegion { <EntityProperty> constant }
[Entity] targetType { <Entity> declaration [field] }
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] Input { <TargetType> constant }
[Entity] targetDir { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
NULL: GameInput
NULL: GetAxis
NULL: AxisType
NULL: Horizontal
NULL: GameInput
NULL: GetAxis
NULL: AxisType
NULL: Vertical
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] Player { <TargetType> constant }
[Entity] targetPos { <Entity> declaration [field] }
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
NULL: position
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] Target { <TargetType> constant }
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] Random { <TargetType> constant }
[Entity] targetDir { <Entity> declaration [field] }
NULL: MathUtils
NULL: RandomVector2
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] MoveDir { <TargetType> constant }
[Entity] targetDir { <Entity> declaration [field] }
NULL: transform
NULL: right
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] MoveRegion { <TargetType> constant }
[Entity] targetPos { <Entity> declaration [field] }
[Entity] moveRegion { <Entity> declaration [field] }
NULL: max
[Entity] targetPos { <Entity> declaration [field] }
[Entity] moveRegion { <Entity> declaration [field] }
NULL: min
[{] SwitchTargetToMax { <{> function [def] }
[Entity] targetPos { <Entity> declaration [field] }
[Entity] moveRegion { <Entity> declaration [field] }
NULL: max
NULL: MathUtils
NULL: IsApproximate
NULL: transform
NULL: position
[Entity] moveRegion { <Entity> declaration [field] }
NULL: max
[{] SwitchTargetToMax { <{> function [def] }
[Entity] targetPos { <Entity> declaration [field] }
[Entity] moveRegion { <Entity> declaration [field] }
NULL: min
NULL: MathUtils
NULL: IsApproximate
NULL: transform
NULL: position
[Entity] moveRegion { <Entity> declaration [field] }
NULL: min
[{] SwitchTargetToMax { <{> function [def] }
[{] SwitchTargetToMax { <{> function [def] }
[SwitchTargetToMax] toMax { <SwitchTargetToMax> declaration [argument] }
[SwitchTargetToMax] atEndOfMoveRegion { <SwitchTargetToMax> declaration [argument] }
[Entity] targetPos { <Entity> declaration [field] }
[SwitchTargetToMax] toMax { <SwitchTargetToMax> declaration [argument] }
[Entity] moveRegion { <Entity> declaration [field] }
NULL: max
[Entity] moveRegion { <Entity> declaration [field] }
NULL: min
[Entity] velocity { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
NULL: zero
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] AtEndOfMoveRegion { <EntityProperty> constant }
[SwitchTargetToMax] atEndOfMoveRegion { <SwitchTargetToMax> declaration [argument] }
[SwitchTargetToMax] atEndOfMoveRegion { <SwitchTargetToMax> declaration [argument] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] StartAtMinMoveRegion { <EntityProperty> constant }
NULL: transform
NULL: position
[Entity] moveRegion { <Entity> declaration [field] }
NULL: min
NULL: Z
NULL: transform
NULL: position
NULL: z
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] Target { <TargetType> constant }
[Entity] TargetType { <Entity> type [def] [product] }
[TargetType] Target { <TargetType> constant }
[Entity] offsetType { <Entity> declaration [field] }
[Entity] TargetOffsetType { <Entity> type [def] [product] }
[TargetOffsetType] Mouse { <TargetOffsetType> constant }
[Entity] offsetDir { <Entity> declaration [field] }
NULL: GameInput
NULL: GetMouseDir
[Entity] TargetOffsetType { <Entity> type [def] [product] }
[TargetOffsetType] Player { <TargetOffsetType> constant }
[Entity] offsetDir { <Entity> declaration [field] }
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
NULL: Direction
[Entity] targetPos { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[Entity] offsetDir { <Entity> declaration [field] }
[Entity] targetOffset { <Entity> declaration [field] }
[Entity] targetDir { <Entity> declaration [field] }
[Entity] targetPos { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
NULL: transform
NULL: position
[Entity] moveType { <Entity> declaration [field] }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] None { <MoveType> constant }
[Entity] velocity { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
NULL: zero
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] Run { <MoveType> constant }
[Entity] targetDir { <Entity> declaration [field] }
NULL: x
NULL: MathUtils
NULL: Sign
[Entity] targetDir { <Entity> declaration [field] }
NULL: x
[Entity] targetDir { <Entity> declaration [field] }
NULL: y
[Entity] velocity { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[Entity] targetDir { <Entity> declaration [field] }
NULL: x
[Entity] speed { <Entity> declaration [field] }
[Entity] rb { <Entity> declaration [field] }
NULL: velocity
NULL: y
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] Fly { <MoveType> constant }
[Entity] velocity { <Entity> declaration [field] }
[Entity] targetDir { <Entity> declaration [field] }
NULL: normalized
[Entity] speed { <Entity> declaration [field] }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] SmoothDamp { <MoveType> constant }
NULL: transform
NULL: position
NULL: MathUtils
NULL: SmoothDamp
NULL: transform
NULL: position
[Entity] targetPos { <Entity> declaration [field] }
[Entity] velocity { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[Entity] speed { <Entity> declaration [field] }
[Entity] speedY { <Entity> declaration [field] }
NULL: Time
NULL: deltaTime
NULL: transform
NULL: position
NULL: z
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] Spring { <MoveType> constant }
[NULL] Vector2 { type [def] [product] }
[{] newPos { <{> declaration [local] }
[Entity] targetPos { <Entity> declaration [field] }
[{] newPos { <{> declaration [local] }
NULL: y
NULL: MathUtils
NULL: SecondOrder
NULL: Time
NULL: deltaTime
[Entity] targetPos { <Entity> declaration [field] }
NULL: y
NULL: transform
NULL: position
NULL: y
[Entity] spring { <Entity> declaration [field] }
NULL: transform
NULL: position
[{] newPos { <{> declaration [local] }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] Custom { <MoveType> constant }
[Entity] rb { <Entity> declaration [field] }
[Entity] rb { <Entity> declaration [field] }
NULL: velocity
[Entity] velocity { <Entity> declaration [field] }
NULL: transform
NULL: position
NULL: Vector3
[Entity] velocity { <Entity> declaration [field] }
NULL: Time
NULL: deltaTime
[Entity] RotateType { <Entity> type [def] [product] }
[RotateType] None { <RotateType> constant }
[RotateType] PlayerX { <RotateType> constant }
[RotateType] MoveDirX { <RotateType> constant }
[RotateType] Weapon { <RotateType> constant }
[RotateType] MouseX { <RotateType> constant }
[RotateType] Linear { <RotateType> constant }
[RotateType] Count { <RotateType> constant }
[Entity] RotateEntity { <Entity> function [def] }
NULL: Transform
[RotateEntity] transform { <RotateEntity> declaration [argument] }
[Entity] RotateType { <Entity> type [def] [product] }
[RotateEntity] rotateType { <RotateEntity> declaration [argument] }
[RotateEntity] dRotate { <RotateEntity> declaration [argument] }
[RotateEntity] velocityX { <RotateEntity> declaration [argument] }
[RotateEntity] dirX { <RotateEntity> declaration [local] }
NULL: Transform
[RotateEntity] player { <RotateEntity> declaration [local] }
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
NULL: transform
[NULL] Vector2 { type [def] [product] }
[RotateEntity] mouseDir { <RotateEntity> declaration [local] }
NULL: GameInput
NULL: GetDirToMouse
[RotateEntity] transform { <RotateEntity> declaration [argument] }
NULL: position
[RotateEntity] rotateType { <RotateEntity> declaration [argument] }
[Entity] RotateType { <Entity> type [def] [product] }
[RotateType] PlayerX { <RotateType> constant }
[RotateEntity] dirX { <RotateEntity> declaration [local] }
[RotateEntity] player { <RotateEntity> declaration [local] }
NULL: position
NULL: x
[RotateEntity] transform { <RotateEntity> declaration [argument] }
NULL: position
NULL: x
[Entity] RotateType { <Entity> type [def] [product] }
[RotateType] MoveDirX { <RotateType> constant }
[RotateEntity] dirX { <RotateEntity> declaration [local] }
[RotateEntity] velocityX { <RotateEntity> declaration [argument] }
[Entity] RotateType { <Entity> type [def] [product] }
[RotateType] MouseX { <RotateType> constant }
[RotateEntity] dirX { <RotateEntity> declaration [local] }
[RotateEntity] mouseDir { <RotateEntity> declaration [local] }
NULL: x
[Entity] RotateType { <Entity> type [def] [product] }
[RotateType] Weapon { <RotateType> constant }
[RotateEntity] transform { <RotateEntity> declaration [argument] }
NULL: rotation
[NULL] GameManager { type [def] [product] }
[GameManager] player { <GameManager> declaration [field] }
[Entity] fallRemember { <Entity> declaration [field] }
[RotateEntity] player { <RotateEntity> declaration [local] }
NULL: rotation
NULL: MathUtils
NULL: GetQuaternionFlipY
[RotateEntity] mouseDir { <RotateEntity> declaration [local] }
[RotateEntity] player { <RotateEntity> declaration [local] }
NULL: up
NULL: y
[Entity] RotateType { <Entity> type [def] [product] }
[RotateType] Linear { <RotateType> constant }
[RotateEntity] transform { <RotateEntity> declaration [argument] }
NULL: Rotate
[RotateEntity] dRotate { <RotateEntity> declaration [argument] }
NULL: Time
NULL: deltaTime
[RotateEntity] dirX { <RotateEntity> declaration [local] }
NULL: Mathf
NULL: Sign
[RotateEntity] dirX { <RotateEntity> declaration [local] }
NULL: Mathf
NULL: Sign
[RotateEntity] transform { <RotateEntity> declaration [argument] }
NULL: right
NULL: x
[RotateEntity] transform { <RotateEntity> declaration [argument] }
NULL: Rotate
[Entity] StartFalling { <Entity> function [def] }
[StartFalling] startFalling { <StartFalling> declaration [argument] }
[Entity] rb { <Entity> declaration [field] }
NULL: velocity
[StartFalling] startFalling { <StartFalling> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[Entity] fallDir { <Entity> declaration [field] }
[RangedFloat] randomValue { <RangedFloat> declaration [property] }
NULL: Random
NULL: value
NULL: normalized
[Entity] speed { <Entity> declaration [field] }
[NULL] Vector2 { type [def] [product] }
NULL: zero
[Entity] moveType { <Entity> declaration [field] }
[StartFalling] startFalling { <StartFalling> declaration [argument] }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] Custom { <MoveType> constant }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] Fly { <MoveType> constant }
[Entity] cd { <Entity> declaration [field] }
NULL: isTrigger
[StartFalling] startFalling { <StartFalling> declaration [argument] }
[Entity] rb { <Entity> declaration [field] }
NULL: bodyType
[StartFalling] startFalling { <StartFalling> declaration [argument] }
NULL: RigidbodyType2D
NULL: Dynamic
NULL: RigidbodyType2D
NULL: Kinematic
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] FallingOnSpawn { <EntityProperty> constant }
[StartFalling] startFalling { <StartFalling> declaration [argument] }
[StartFalling] startFalling { <StartFalling> declaration [argument] }
[Entity] CalculateMoveRegion { <Entity> function [def] }
[Entity] CompleteCycle { <Entity> function [def] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] AtEndOfMoveRegion { <EntityProperty> constant }
[Entity] targetPos { <Entity> declaration [field] }
[Entity] moveRegion { <Entity> declaration [field] }
NULL: max
[Entity] TestPlayerVFX { <Entity> function [def] }
[NULL] SCRIPTABLE_VFX { macro }
[Entity] Hurt { <Entity> function [def] }
NULL: VFX
[TestPlayerVFX] vfx1 { <TestPlayerVFX> declaration [local] }
[TestPlayerVFX] CreateTestVFX { <TestPlayerVFX> function [def] }
[NULL] RangedFloat { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
NULL: VFX
[TestPlayerVFX] vfx2 { <TestPlayerVFX> declaration [local] }
[TestPlayerVFX] CreateTestVFX { <TestPlayerVFX> function [def] }
[NULL] RangedFloat { type [def] [product] }
[NULL] Vector2 { type [def] [product] }
NULL: StartCoroutine
[Entity] PlayVFX { <Entity> function [def] }
[TestPlayerVFX] vfx1 { <TestPlayerVFX> declaration [local] }
NULL: StartCoroutine
[Entity] PlayVFX { <Entity> function [def] }
[TestPlayerVFX] vfx2 { <TestPlayerVFX> declaration [local] }
NULL: VFX
[TestPlayerVFX] CreateTestVFX { <TestPlayerVFX> function [def] }
[CreateTestVFX] name { <CreateTestVFX> declaration [argument] }
[NULL] RangedFloat { type [def] [product] }
[CreateTestVFX] timeline { <CreateTestVFX> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[CreateTestVFX] offset { <CreateTestVFX> declaration [argument] }
NULL: VFX
[CreateTestVFX] vfx { <CreateTestVFX> declaration [local] }
NULL: ScriptableObject
NULL: CreateInstance
NULL: VFX
[CreateTestVFX] vfx { <CreateTestVFX> declaration [local] }
NULL: name
[CreateTestVFX] name { <CreateTestVFX> declaration [argument] }
[CreateTestVFX] vfx { <CreateTestVFX> declaration [local] }
NULL: offset
[CreateTestVFX] offset { <CreateTestVFX> declaration [argument] }
[CreateTestVFX] vfx { <CreateTestVFX> declaration [local] }
NULL: flags
NULL: SetProperty
NULL: VFXFlag
NULL: OffsetScale
[CreateTestVFX] vfx { <CreateTestVFX> declaration [local] }
NULL: timeline
[CreateTestVFX] timeline { <CreateTestVFX> declaration [argument] }
[CreateTestVFX] vfx { <CreateTestVFX> declaration [local] }
[Entity] Hurt { <Entity> function [def] }
[Hurt] damage { <Hurt> declaration [argument] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] CanBeHurt { <EntityProperty> constant }
[Entity] health { <Entity> declaration [field] }
[Hurt] damage { <Hurt> declaration [argument] }
[Entity] moveType { <Entity> declaration [field] }
[Entity] MoveType { <Entity> type [def] [product] }
[MoveType] None { <MoveType> constant }
[Entity] rotateType { <Entity> declaration [field] }
[Entity] RotateType { <Entity> type [def] [product] }
[RotateType] None { <RotateType> constant }
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] CanBeHurt { <EntityProperty> constant }
[Entity] health { <Entity> declaration [field] }
[Entity] state { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[EntityState] OnHit { <EntityState> constant }
[Entity] Die { <Entity> function [def] }
[Entity] Die { <Entity> function [def] }
[Entity] state { <Entity> declaration [field] }
[NULL] EntityState { type [def] [product] }
[EntityState] OnDeath { <EntityState> constant }
[Entity] PlayVFX { <Entity> function [def] }
[Entity] deathVFX { <Entity> declaration [field] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[HasProperty] property { <HasProperty> declaration [argument] }
[Entity] properties { <Entity> declaration [field] }
NULL: HasProperty
[HasProperty] property { <HasProperty> declaration [argument] }
[Entity] SetProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[SetProperty] property { <SetProperty> declaration [argument] }
[SetProperty] set { <SetProperty> declaration [argument] }
[Entity] properties { <Entity> declaration [field] }
NULL: SetProperty
[SetProperty] property { <SetProperty> declaration [argument] }
[SetProperty] set { <SetProperty> declaration [argument] }
[SetProperty] set { <SetProperty> declaration [argument] }
[Entity] OnTriggerEnter2D { <Entity> function [def] }
NULL: Collider2D
[OnTriggerEnter2D] collision { <OnTriggerEnter2D> declaration [argument] }
[Entity] OnHitEnter { <Entity> function [def] }
[OnTriggerEnter2D] collision { <OnTriggerEnter2D> declaration [argument] }
[Entity] OnCollisionEnter2D { <Entity> function [def] }
NULL: Collision2D
[OnCollisionEnter2D] collision { <OnCollisionEnter2D> declaration [argument] }
[Entity] OnHitEnter { <Entity> function [def] }
[OnCollisionEnter2D] collision { <OnCollisionEnter2D> declaration [argument] }
NULL: collider
[Entity] OnHitEnter { <Entity> function [def] }
NULL: Collider2D
[OnHitEnter] collision { <OnHitEnter> declaration [argument] }
[OnHitEnter] tag { <OnHitEnter> declaration [local] }
[Entity] collisionTags { <Entity> declaration [field] }
[OnHitEnter] collision { <OnHitEnter> declaration [argument] }
NULL: CompareTag
[OnHitEnter] tag { <OnHitEnter> declaration [local] }
[NULL] Entity { type [def] [product] }
[{] entity { <{> declaration [local] }
[{] entity { <{> declaration [local] }
[OnHitEnter] collision { <OnHitEnter> declaration [argument] }
NULL: GetComponent
[NULL] Entity { type [def] [product] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] DamageWhenCollide { <EntityProperty> constant }
[{] entity { <{> declaration [local] }
[Entity] Hurt { <Entity> function [def] }
[Entity] damage { <Entity> declaration [field] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] AddMoneyWhenCollide { <EntityProperty> constant }
[{] entity { <{> declaration [local] }
[Entity] money { <Entity> declaration [field] }
[Entity] money { <Entity> declaration [field] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] DieWhenCollide { <EntityProperty> constant }
[Entity] Die { <Entity> function [def] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] SpawnDamagePopup { <EntityProperty> constant }
NULL: ObjectPooler
NULL: Spawn
[NULL] Entity { type [def] [product] }
NULL: PoolType
NULL: DamagePopup
NULL: transform
NULL: position
NULL: InitDamagePopup
[Entity] damage { <Entity> declaration [field] }
[Entity] HasProperty { <Entity> function [def] }
[NULL] EntityProperty { type [def] [product] }
[EntityProperty] IsCritical { <EntityProperty> constant }
[Entity] IsInRange { <Entity> function [def] }
[IsInRange] range { <IsInRange> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[IsInRange] targetPos { <IsInRange> declaration [argument] }
[IsInRange] targetPos { <IsInRange> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
NULL: transform
NULL: position
NULL: sqrMagnitude
[IsInRange] range { <IsInRange> declaration [argument] }
[IsInRange] range { <IsInRange> declaration [argument] }
[Entity] IsInRange { <Entity> function [def] }
[NULL] Vector2 { type [def] [product] }
[IsInRange] range { <IsInRange> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[IsInRange] targetPos { <IsInRange> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[IsInRange] targetDir { <IsInRange> declaration [local] }
NULL: MathUtils
NULL: Abs
[IsInRange] targetPos { <IsInRange> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
NULL: transform
NULL: position
[IsInRange] targetDir { <IsInRange> declaration [local] }
NULL: x
[IsInRange] range { <IsInRange> declaration [argument] }
NULL: x
[IsInRange] targetDir { <IsInRange> declaration [local] }
NULL: y
[IsInRange] range { <IsInRange> declaration [argument] }
NULL: y
[Entity] IsInRangeY { <Entity> function [def] }
[IsInRangeY] range { <IsInRangeY> declaration [argument] }
[NULL] Vector2 { type [def] [product] }
[IsInRangeY] targetPos { <IsInRangeY> declaration [argument] }
NULL: Mathf
NULL: Abs
[IsInRangeY] targetPos { <IsInRangeY> declaration [argument] }
NULL: y
NULL: transform
NULL: position
NULL: y
[IsInRangeY] range { <IsInRangeY> declaration [argument] }
[Entity] CalculateMoveRegion { <Entity> function [def] }
[Entity] regionType { <Entity> declaration [field] }
[Entity] MoveRegionType { <Entity> type [def] [product] }
[MoveRegionType] Ground { <MoveRegionType> constant }
[Entity] moveRegion { <Entity> declaration [field] }
[NULL] GameManager { type [def] [product] }
[GameManager] CalculateMoveRegion { <GameManager> function [def] }
NULL: transform
NULL: position
[Entity] spriteExtents { <Entity> declaration [field] }
NULL: transform
NULL: up
NULL: y
[Entity] MoveRegionType { <Entity> type [def] [product] }
[MoveRegionType] Vertical { <MoveRegionType> constant }
NULL: Debug
NULL: Assert
NULL: transform
NULL: up
NULL: y
[NULL] GameManager { type [def] [product] }
[GameManager] GetGroundPos { <GameManager> function [def] }
NULL: transform
NULL: position
[Entity] spriteExtents { <Entity> declaration [field] }
NULL: f
NULL: _
NULL: Vector3Int
[{] groundPos { <{> declaration [local] }
[Entity] moveRegion { <Entity> declaration [field] }
NULL: Rect
[NULL] Vector2 { type [def] [product] }
NULL: transform
NULL: position
NULL: x
[{] groundPos { <{> declaration [local] }
NULL: y
[Entity] spriteExtents { <Entity> declaration [field] }
NULL: y
[NULL] Vector2 { type [def] [product] }
NULL: up
[Entity] verticalHeight { <Entity> declaration [field] }
NULL: GameDebug
NULL: DrawBox
NULL: Rect
NULL: Vector3
[{] groundPos { <{> declaration [local] }
[Entity] spriteExtents { <Entity> declaration [field] }
NULL: Color
NULL: red
NULL: VFX
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] StopAnimation { <VFXProperty> constant }
[VFXProperty] ChangeEffectObjBack { <VFXProperty> constant }
[VFXProperty] ScaleOverTime { <VFXProperty> constant }
[VFXProperty] FadeTextWhenDone { <VFXProperty> constant }
[VFXProperty] StartTrailing { <VFXProperty> constant }
[VFXProperty] DecreaseTrailWidth { <VFXProperty> constant }
[VFXProperty] PlayParticleInOrder { <VFXProperty> constant }
[VFXProperty] FlipX { <VFXProperty> constant }
[VFXProperty] FlipY { <VFXProperty> constant }
[VFXProperty] FlipZ { <VFXProperty> constant }
NULL: SomeOtherThing
NULL: Multiple
NULL: System
NULL: Serializable
[Entity] EntityVFX { <Entity> type [def] [product] }
[NULL] Property { type [def] [product] }
[Entity] VFXProperty { <Entity> type [def] [product] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: System
NULL: Action
[EntityVFX] done { <EntityVFX> declaration [field] }
NULL: System
NULL: Func
[EntityVFX] canStop { <EntityVFX> declaration [field] }
[EntityVFX] nextAnimation { <EntityVFX> declaration [field] }
NULL: GameObject
[EntityVFX] effectObj { <EntityVFX> declaration [field] }
NULL: ParticleSystem
[EntityVFX] particles { <EntityVFX> declaration [field] }
NULL: Header
[EntityVFX] waitTime { <EntityVFX> declaration [field] }
[EntityVFX] scaleTime { <EntityVFX> declaration [field] }
[EntityVFX] rotateTime { <EntityVFX> declaration [field] }
NULL: Header
[EntityVFX] trailEmitTime { <EntityVFX> declaration [field] }
[EntityVFX] trailStayTime { <EntityVFX> declaration [field] }
NULL: Header
[EntityVFX] flashTime { <EntityVFX> declaration [field] }
[EntityVFX] flashDuration { <EntityVFX> declaration [field] }
NULL: Color
[EntityVFX] triggerColor { <EntityVFX> declaration [field] }
NULL: Header
NULL: Color
[EntityVFX] textColor { <EntityVFX> declaration [field] }
[EntityVFX] fontSize { <EntityVFX> declaration [field] }
NULL: Header
[EntityVFX] stopTime { <EntityVFX> declaration [field] }
[EntityVFX] trauma { <EntityVFX> declaration [field] }
NULL: ShakeMode
[EntityVFX] shakeMode { <EntityVFX> declaration [field] }
[EntityVFX] shockSpeed { <EntityVFX> declaration [field] }
[EntityVFX] shockSize { <EntityVFX> declaration [field] }
[EntityVFX] camFlashTime { <EntityVFX> declaration [field] }
[EntityVFX] camFlashAlpha { <EntityVFX> declaration [field] }
NULL: Header
[EntityVFX] alpha { <EntityVFX> declaration [field] }
[EntityVFX] fadeTime { <EntityVFX> declaration [field] }
NULL: Header
[EntityVFX] range { <EntityVFX> declaration [field] }
NULL: ParticleType
[EntityVFX] particleType { <EntityVFX> declaration [field] }
NULL: Header
NULL: AudioType
[EntityVFX] audio { <EntityVFX> declaration [field] }
NULL: PoolType
[EntityVFX] poolType { <EntityVFX> declaration [field] }
[NULL] Vector2 { type [def] [product] }
[EntityVFX] scaleOffset { <EntityVFX> declaration [field] }
[Entity] PlayVFX { <Entity> function [def] }
[Entity] EntityVFX { <Entity> type [def] [product] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
NULL: Debug
NULL: Log
[Entity] state { <Entity> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] ScaleOverTime { <VFXProperty> constant }
NULL: StartCoroutine
[PlayVFX] ScaleOverTime { <PlayVFX> function [def] }
NULL: transform
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] scaleTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] scaleOffset { <EntityVFX> declaration [field] }
NULL: transform
NULL: localScale
NULL: Vector3
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] scaleOffset { <EntityVFX> declaration [field] }
NULL: IsNullOrEmpty
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] nextAnimation { <EntityVFX> declaration [field] }
[Entity] anim { <Entity> declaration [field] }
NULL: Play
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] nextAnimation { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] StopAnimation { <VFXProperty> constant }
[Entity] anim { <Entity> declaration [field] }
NULL: speed
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] textColor { <EntityVFX> declaration [field] }
NULL: Color
NULL: clear
[Entity] text { <Entity> declaration [field] }
NULL: color
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] textColor { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] fontSize { <EntityVFX> declaration [field] }
[Entity] text { <Entity> declaration [field] }
NULL: fontSize
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] fontSize { <EntityVFX> declaration [field] }
[PlayVFX] totalParticleTime { <PlayVFX> declaration [local] }
[PlayVFX] particleCount { <PlayVFX> declaration [local] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] particles { <EntityVFX> declaration [field] }
NULL: Length
[PlayVFX] i { <PlayVFX> declaration [local] }
[PlayVFX] i { <PlayVFX> declaration [local] }
[PlayVFX] particleCount { <PlayVFX> declaration [local] }
[PlayVFX] i { <PlayVFX> declaration [local] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] particles { <EntityVFX> declaration [field] }
[PlayVFX] i { <PlayVFX> declaration [local] }
NULL: InvokeAfter
[PlayVFX] totalParticleTime { <PlayVFX> declaration [local] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] particles { <EntityVFX> declaration [field] }
[PlayVFX] i { <PlayVFX> declaration [local] }
NULL: Play
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] PlayParticleInOrder { <VFXProperty> constant }
[PlayVFX] totalParticleTime { <PlayVFX> declaration [local] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] particles { <EntityVFX> declaration [field] }
[PlayVFX] i { <PlayVFX> declaration [local] }
NULL: main
NULL: duration
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] effectObj { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] effectObj { <EntityVFX> declaration [field] }
NULL: SetActive
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] effectObj { <EntityVFX> declaration [field] }
NULL: activeSelf
NULL: StartCoroutine
NULL: CameraSystem
NULL: instance
NULL: Flash
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] camFlashTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] camFlashAlpha { <EntityVFX> declaration [field] }
NULL: CameraSystem
NULL: instance
NULL: Shake
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] shakeMode { <EntityVFX> declaration [field] }
NULL: CameraSystem
NULL: instance
NULL: Shock
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] shockSpeed { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] shockSize { <EntityVFX> declaration [field] }
NULL: AudioManager
NULL: PlayAudio
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] audio { <EntityVFX> declaration [field] }
NULL: ObjectPooler
NULL: Spawn
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] poolType { <EntityVFX> declaration [field] }
NULL: transform
NULL: position
NULL: ParticleEffect
NULL: instance
NULL: SpawnParticle
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] particleType { <EntityVFX> declaration [field] }
NULL: transform
NULL: position
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] range { <EntityVFX> declaration [field] }
NULL: StartCoroutine
NULL: GameUtils
NULL: StopTime
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] stopTime { <EntityVFX> declaration [field] }
NULL: StartCoroutine
[PlayVFX] Flashing { <PlayVFX> function [def] }
[Entity] sr { <Entity> declaration [field] }
[Entity] whiteMat { <Entity> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] triggerColor { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] flashDuration { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] flashTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] canStop { <EntityVFX> declaration [field] }
[PlayVFX] x { <PlayVFX> declaration [local] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] FlipX { <VFXProperty> constant }
[PlayVFX] y { <PlayVFX> declaration [local] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] FlipY { <VFXProperty> constant }
[PlayVFX] z { <PlayVFX> declaration [local] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] FlipZ { <VFXProperty> constant }
[PlayVFX] x { <PlayVFX> declaration [local] }
[PlayVFX] y { <PlayVFX> declaration [local] }
[PlayVFX] z { <PlayVFX> declaration [local] }
NULL: InvokeAfter
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] rotateTime { <EntityVFX> declaration [field] }
NULL: transform
NULL: Rotate
NULL: Vector3
[PlayVFX] x { <PlayVFX> declaration [local] }
[PlayVFX] y { <PlayVFX> declaration [local] }
[PlayVFX] z { <PlayVFX> declaration [local] }
NULL: InvokeAfter
NULL: Mathf
NULL: Max
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] flashDuration { <EntityVFX> declaration [field] }
[PlayVFX] totalParticleTime { <PlayVFX> declaration [local] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] scaleTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] FadeTextWhenDone { <VFXProperty> constant }
NULL: StartCoroutine
[PlayVFX] FadeText { <PlayVFX> function [def] }
[Entity] text { <Entity> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] alpha { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] fadeTime { <EntityVFX> declaration [field] }
NULL: StartCoroutine
[PlayVFX] Flashing { <PlayVFX> function [def] }
[Entity] sr { <Entity> declaration [field] }
[Entity] whiteMat { <Entity> declaration [field] }
NULL: Color
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] alpha { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] fadeTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] fadeTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] canStop { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] StartTrailing { <VFXProperty> constant }
NULL: StartCoroutine
[PlayVFX] EnableTrail { <PlayVFX> function [def] }
[Entity] trail { <Entity> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] trailEmitTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] trailStayTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] DecreaseTrailWidth { <VFXProperty> constant }
NULL: InvokeAfter
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] trailEmitTime { <EntityVFX> declaration [field] }
NULL: StartCoroutine
[PlayVFX] DecreaseTrailWidth { <PlayVFX> function [def] }
[Entity] trail { <Entity> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] trailStayTime { <EntityVFX> declaration [field] }
NULL: InvokeAfter
NULL: Mathf
NULL: Max
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] fadeTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] trailEmitTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] trailStayTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] waitTime { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] ScaleOverTime { <VFXProperty> constant }
NULL: transform
NULL: localScale
NULL: Vector3
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] scaleOffset { <EntityVFX> declaration [field] }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] properties { <EntityVFX> declaration [field] }
NULL: HasProperty
[Entity] VFXProperty { <Entity> type [def] [product] }
[VFXProperty] ChangeEffectObjBack { <VFXProperty> constant }
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] effectObj { <EntityVFX> declaration [field] }
NULL: SetActive
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] effectObj { <EntityVFX> declaration [field] }
NULL: activeSelf
[Entity] anim { <Entity> declaration [field] }
[Entity] anim { <Entity> declaration [field] }
NULL: speed
[PlayVFX] vfx { <PlayVFX> declaration [argument] }
[EntityVFX] done { <EntityVFX> declaration [field] }
NULL: Invoke
NULL: IEnumerator
[PlayVFX] Flashing { <PlayVFX> function [def] }
NULL: SpriteRenderer
[Flashing] sr { <Flashing> declaration [argument] }
NULL: Material
[Flashing] whiteMat { <Flashing> declaration [argument] }
NULL: Color
[Flashing] color { <Flashing> declaration [argument] }
[Flashing] duration { <Flashing> declaration [argument] }
[Flashing] flashTime { <Flashing> declaration [argument] }
NULL: System
NULL: Func
[Flashing] canStop { <Flashing> declaration [argument] }
[Flashing] whiteMat { <Flashing> declaration [argument] }
[Flashing] whiteMat { <Flashing> declaration [argument] }
NULL: color
[Flashing] color { <Flashing> declaration [argument] }
[Flashing] duration { <Flashing> declaration [argument] }
[Flashing] canStop { <Flashing> declaration [argument] }
NULL: Invoke
[{] currentTime { <{> declaration [local] }
NULL: Time
NULL: time
NULL: Material
[{] defMat { <{> declaration [local] }
[Flashing] sr { <Flashing> declaration [argument] }
NULL: material
[Flashing] sr { <Flashing> declaration [argument] }
NULL: material
[Flashing] whiteMat { <Flashing> declaration [argument] }
NULL: WaitForSeconds
[Flashing] flashTime { <Flashing> declaration [argument] }
[Flashing] sr { <Flashing> declaration [argument] }
NULL: material
[{] defMat { <{> declaration [local] }
NULL: WaitForSeconds
[Flashing] flashTime { <Flashing> declaration [argument] }
[Flashing] duration { <Flashing> declaration [argument] }
NULL: Time
NULL: time
[{] currentTime { <{> declaration [local] }
[Flashing] whiteMat { <Flashing> declaration [argument] }
NULL: color
NULL: Color
NULL: white
NULL: IEnumerator
[PlayVFX] ScaleOverTime { <PlayVFX> function [def] }
NULL: Transform
[ScaleOverTime] transform { <ScaleOverTime> declaration [argument] }
[ScaleOverTime] duration { <ScaleOverTime> declaration [argument] }
NULL: Vector3
[ScaleOverTime] scaleOffset { <ScaleOverTime> declaration [argument] }
[ScaleOverTime] duration { <ScaleOverTime> declaration [argument] }
[ScaleOverTime] duration { <ScaleOverTime> declaration [argument] }
NULL: Time
NULL: deltaTime
[ScaleOverTime] transform { <ScaleOverTime> declaration [argument] }
NULL: localScale
[ScaleOverTime] scaleOffset { <ScaleOverTime> declaration [argument] }
NULL: Time
NULL: deltaTime
[ScaleOverTime] transform { <ScaleOverTime> declaration [argument] }
NULL: gameObject
NULL: activeSelf
[ScaleOverTime] transform { <ScaleOverTime> declaration [argument] }
NULL: localScale
[ScaleOverTime] scaleOffset { <ScaleOverTime> declaration [argument] }
NULL: Time
NULL: deltaTime
NULL: IEnumerator
[PlayVFX] FadeText { <PlayVFX> function [def] }
NULL: TMPro
NULL: TextMeshPro
[FadeText] text { <FadeText> declaration [argument] }
[FadeText] alpha { <FadeText> declaration [argument] }
[FadeText] fadeTime { <FadeText> declaration [argument] }
[FadeText] dAlpha { <FadeText> declaration [local] }
[FadeText] text { <FadeText> declaration [argument] }
NULL: alpha
[FadeText] alpha { <FadeText> declaration [argument] }
[FadeText] fadeTime { <FadeText> declaration [argument] }
[FadeText] text { <FadeText> declaration [argument] }
NULL: alpha
[FadeText] alpha { <FadeText> declaration [argument] }
[FadeText] text { <FadeText> declaration [argument] }
NULL: alpha
[FadeText] dAlpha { <FadeText> declaration [local] }
NULL: Time
NULL: deltaTime
NULL: IEnumerator
[PlayVFX] EnableTrail { <PlayVFX> function [def] }
NULL: TrailRenderer
[EnableTrail] trail { <EnableTrail> declaration [argument] }
[EnableTrail] emitTime { <EnableTrail> declaration [argument] }
[EnableTrail] stayTime { <EnableTrail> declaration [argument] }
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: enabled
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: emitting
NULL: WaitForSeconds
[EnableTrail] emitTime { <EnableTrail> declaration [argument] }
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: emitting
NULL: WaitForSeconds
[EnableTrail] stayTime { <EnableTrail> declaration [argument] }
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: Clear
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: emitting
[EnableTrail] trail { <EnableTrail> declaration [argument] }
NULL: enabled
NULL: IEnumerator
[PlayVFX] DecreaseTrailWidth { <PlayVFX> function [def] }
NULL: TrailRenderer
[DecreaseTrailWidth] trail { <DecreaseTrailWidth> declaration [argument] }
[DecreaseTrailWidth] decreaseTime { <DecreaseTrailWidth> declaration [argument] }
[DecreaseTrailWidth] startWidth { <DecreaseTrailWidth> declaration [local] }
[DecreaseTrailWidth] trail { <DecreaseTrailWidth> declaration [argument] }
NULL: widthMultiplier
[DecreaseTrailWidth] startTime { <DecreaseTrailWidth> declaration [local] }
[DecreaseTrailWidth] decreaseTime { <DecreaseTrailWidth> declaration [argument] }
[DecreaseTrailWidth] decreaseTime { <DecreaseTrailWidth> declaration [argument] }
[DecreaseTrailWidth] trail { <DecreaseTrailWidth> declaration [argument] }
NULL: widthMultiplier
[DecreaseTrailWidth] decreaseTime { <DecreaseTrailWidth> declaration [argument] }
[DecreaseTrailWidth] startTime { <DecreaseTrailWidth> declaration [local] }
[DecreaseTrailWidth] startWidth { <DecreaseTrailWidth> declaration [local] }
[DecreaseTrailWidth] decreaseTime { <DecreaseTrailWidth> declaration [argument] }
NULL: Time
NULL: deltaTime
[DecreaseTrailWidth] trail { <DecreaseTrailWidth> declaration [argument] }
NULL: widthMultiplier
[DecreaseTrailWidth] startWidth { <DecreaseTrailWidth> declaration [local] }
Note count: 4397